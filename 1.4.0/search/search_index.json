{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Medchem","text":"<p>Package for applying common medchem filters to a dataset of molecules.</p>"},{"location":"index.html#summary","title":"Summary","text":"<p>This package contains various implementation of medchem rules collected from various sources that may be applied as filters on generated or screened molecules. It centralizes all common filters used at Valence Discovery.</p> <p>Although the list is as exhaustive as possible, filtering rules mainly depends on the drug discovery programs.</p> <p>It should be noted that systematically applying all filters is to be avoided. For example, \"PAINS C\" filters are usually not very relevant, another example is the filtering are very strict and could flag important substructure for a project (example some ZBGs).</p>"},{"location":"index.html#installation","title":"Installation","text":"<pre><code>micromamba install -c conda-forge medchem\n</code></pre>"},{"location":"index.html#available-filters","title":"Available Filters","text":"<p>The following filters are available:</p>"},{"location":"index.html#eli-lilly-medchem-rules","title":"Eli Lilly Medchem Rules","text":"<p>These are python binding of the implementation of Eli Lilly Medchem Rules published under \"Rules for Identifying Potentially Reactive or Promiscuous Compounds\" by Robert F. Bruns and Ian W. Watson, J. Med. Chem. 2012, 55, 9763--9772 as ACS Author choice, i.e. open access at doi 10.1021/jm301008n.</p> <p>These rules are used in <code>medchem.filter.lilly_demerit_filter</code> function and are the main offering of this package.</p>"},{"location":"index.html#nibr-filters","title":"NIBR filters","text":"<p>Rules used by Novartis to build their new screening deck. The rules are published under \"Evolution of Novartis' small molecule screening deck design\" by Schuffenhauer, A. et al. J. Med. Chem. (2020), https://dx.doi.org/10.1021/acs.jmedchem.0c01332.</p> <p>These rules are used in lead filtering as <code>medchem.filter.lead.screening_filter</code></p>"},{"location":"index.html#bredt-filters","title":"Bredt filters","text":"<p>These are filters based on the Bredt's rules for unstable chemistry.There are used in lead filtering as <code>medchem.filter.lead.bredt_filter</code>.</p>"},{"location":"index.html#alerts-filters","title":"Alerts filters","text":"<p>These are alerts rules from the ChEMBL database curation scheme and public litterature on promiscuous compounds on commons assays. The rule set are:</p> name # alerts source Glaxo 55 ChEMBL Dundee 105 ChEMBL BMS 180 ChEMBL PAINS 481 ChEMBL SureChEMBL 166 ChEMBL MLSMR 116 ChEMBL Inpharmatica 91 ChEMBL LINT 57 ChEMBL Alarm-NMR 75 Litterature AlphaScreen-Hitters 6 Litterature GST-Hitters 34 Litterature HIS-Hitters 19 Litterature LuciferaseInhibitor 3 Litterature DNABinder 78 Litterature Chelator 55 Litterature Frequent-Hitter 15 Litterature Electrophilic 119 Litterature Genotoxic-Carcinogenicity 117 Litterature LD50-Oral 20 Litterature Non-Genotoxic-Carcinogenicity 22 Litterature Reactive-Unstable-Toxic 335 Litterature Skin 155 Litterature Toxicophore 154 Litterature <p>There are used in lead filtering through <code>medchem.filter.lead.alert_filter</code></p>"},{"location":"index.html#generic-filters","title":"Generic filters","text":"<p>These are generic filters based on specific molecular property such as number of atoms, size of macrocycles, etc. They are available at <code>medchem.filter.generic</code></p>"},{"location":"api/medchem.alerts.html","title":"<code>medchem.alerts</code>","text":""},{"location":"api/medchem.alerts.html#medchem.alerts","title":"<code>medchem.alerts</code>","text":""},{"location":"api/medchem.alerts.html#medchem.alerts.AlertFilters","title":"<code>AlertFilters</code>","text":"<p>Filtering class for building a library based on a list of structural alerts</p> <p>To list the available alerts, use the <code>list_default_available_alerts</code> method.</p>"},{"location":"api/medchem.alerts.html#medchem.alerts.AlertFilters.__call__","title":"<code>__call__(mols, n_jobs=None, progress=False, include_all_alerts=False)</code>","text":"<p>Run alert evaluation on this list of molecule and return the full dataframe</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, rdchem.Mol]]</code> <p>input list of molecules</p> required <code>n_jobs</code> <code>Optional[int]</code> <p>number of jobs</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress or not</p> <code>False</code> <code>include_all_alerts</code> <code>bool</code> <p>whether to include all of the alerts that match as columns</p> <code>False</code>"},{"location":"api/medchem.alerts.html#medchem.alerts.AlertFilters.__init__","title":"<code>__init__(alerts_set=None, alerts_db=None)</code>","text":"<p>Filtering molecules based on chemical alerts</p> <p>Parameters:</p> Name Type Description Default <code>alerts_set</code> <code>Union[str, List[str]]</code> <p>Alerts catalog to use. Default is BMS+Dundee+Glaxo</p> <code>None</code> <code>alerts_db</code> <code>Optional[os.PathLike]</code> <p>Alerts file to use. Default is internal</p> <code>None</code>"},{"location":"api/medchem.alerts.html#medchem.alerts.AlertFilters.evaluate","title":"<code>evaluate(mol)</code>","text":"<p>Evaluate structure alerts on a molecule</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[str, rdchem.Mol]</code> <p>input molecule</p> required <p>Returns:</p> Type Description <p>list of alerts matched</p>"},{"location":"api/medchem.alerts.html#medchem.alerts.AlertFilters.list_default_available_alerts","title":"<code>list_default_available_alerts()</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Return a list of unique rule set names</p>"},{"location":"api/medchem.alerts.html#medchem.alerts.NovartisFilters","title":"<code>NovartisFilters</code>","text":"<p>Filtering class for building a screening deck following the novartis filtering process published in https://dx.doi.org/10.1021/acs.jmedchem.0c01332.</p> <p>The output of the filter are explained below: - status: one of <code>[\"Exclude\", \"Flag\", \"Annotations\", \"Ok\"]</code> (ordered by quality).     Generally, you can keep anything without the \"Exclude\" label, as long as you also apply     a maximum severity score for compounds that collects too many flags. - covalent: number of potentially covalent motifs contained in the compound - severity: how severe are the issues with the molecules:     - <code>0</code>: compound has no flags, might have annotations;     - <code>1-9</code>:  number of flags the compound raises;     - <code>&gt;= 10</code>:  default exclusion criterion used in the paper - special_mol: whether the compound/parts of the compound belongs to a special class of molecules     (e.g peptides, glycosides, fatty acid). In that case, you should review the rejection reasons.</p>"},{"location":"api/medchem.alerts.html#medchem.alerts.NovartisFilters.__call__","title":"<code>__call__(mols, n_jobs=None, progress=False)</code>","text":"<p>Run alert evaluation on this list of molecule and return the full dataframe</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, rdchem.Mol]]</code> <p>input list of molecules</p> required <code>n_jobs</code> <code>Optional[int]</code> <p>number of jobs</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress or not</p> <code>False</code>"},{"location":"api/medchem.catalog.html","title":"<code>medchem.catalog</code>","text":""},{"location":"api/medchem.catalog.html#medchem.catalog","title":"<code>medchem.catalog</code>","text":""},{"location":"api/medchem.catalog.html#medchem.catalog.NamedCatalogs","title":"<code>NamedCatalogs</code>","text":"<p>Holder for substructure matching catalogs</p>"},{"location":"api/medchem.catalog.html#medchem.catalog.NamedCatalogs.alerts","title":"<code>alerts(subset=None)</code>  <code>staticmethod</code>","text":"<p>Alerts filter catalogs commonly used in molecule filtering</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>Optional[Union[List[str], str]]</code> <p>subset of providers to consider</p> <code>None</code> <p>Returns:</p> Name Type Description <code>catalog</code> <code>FilterCatalog</code> <p>filter catalog</p>"},{"location":"api/medchem.catalog.html#medchem.catalog.NamedCatalogs.bredt","title":"<code>bredt()</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Bredt fitler rules Also see example of usage by surge's https://github.com/StructureGenerator/SURGE/blob/main/doc/surge1_0.pdf</p>"},{"location":"api/medchem.catalog.html#medchem.catalog.NamedCatalogs.chemical_groups","title":"<code>chemical_groups(filters='medicinal')</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Chemical group filter catalogs</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>Union[str, List[str]]</code> <p>list of tag to filter the catalog on.</p> <code>'medicinal'</code>"},{"location":"api/medchem.catalog.html#medchem.catalog.NamedCatalogs.nibr","title":"<code>nibr()</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Catalog from NIBR</p> <p>Warning</p> <p>This includes all the compounds in the catalog, regardless of severity (FLAG, EXCLUDE, ANNOTATION) You likely don't want to use this for blind prioritization</p>"},{"location":"api/medchem.catalog.html#medchem.catalog.NamedCatalogs.tox","title":"<code>tox(pains_a=True, pains_b=True, pains_c=False, brenk=True, nih=False, zinc=False)</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Common toxicity and interference catalog</p> <p>Parameters:</p> Name Type Description Default <code>pains_a</code> <code>bool</code> <p>whether to include PAINS filters from assay A</p> <code>True</code> <code>pains_b</code> <code>bool</code> <p>whether to include PAINS filters from assay B</p> <code>True</code> <code>pains_c</code> <code>bool</code> <p>whether to include PAINS filters from assay C</p> <code>False</code> <code>brenk</code> <code>bool</code> <p>whether to include BRENK filters</p> <code>True</code> <code>nih</code> <code>bool</code> <p>whether to include NIH filters</p> <code>False</code> <code>zinc</code> <code>bool</code> <p>whether to include ZINC filters</p> <code>False</code>"},{"location":"api/medchem.catalog.html#medchem.catalog.NamedCatalogs.unstable_graph","title":"<code>unstable_graph(max_severity=5)</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Unstable molecular graph to filter out especially for generative models</p> <p>Parameters:</p> Name Type Description Default <code>max_severity</code> <code>int</code> <p>maximum severity to consider for graph rules to be acceptable</p> <code>5</code>"},{"location":"api/medchem.catalog.html#medchem.catalog.from_smarts","title":"<code>from_smarts(smarts, labels=None, mincounts=None, maxcounts=None, entry_as_inds=False)</code>","text":"<p>Load catalog from a list of smarts</p> <p>Parameters:</p> Name Type Description Default <code>smarts</code> <code>List[str]</code> <p>list of input smarts to add to the catalog</p> required <code>labels</code> <code>Optional[List[str]]</code> <p>list of label for each smarts</p> <code>None</code> <code>mincounts</code> <code>Optional[List[int]]</code> <p>minimum count before a match is recognized</p> <code>None</code> <code>maxcounts</code> <code>Optional[List[int]]</code> <p>maximum count for a match to be valid</p> <code>None</code> <code>entry_as_inds</code> <code>bool</code> <p>whether to use index for entry id or the label</p> <code>False</code> <p>Returns:</p> Name Type Description <code>catalog</code> <code>FilterCatalog</code> <p>merged catalogs</p>"},{"location":"api/medchem.catalog.html#medchem.catalog.list_named_catalogs","title":"<code>list_named_catalogs()</code>","text":"<p>List all available named catalogs. This list will ignore all chemical groups For a list of chemical group to be queried using NamedCatalog.chemical_groups, use <code>medchem.group.list_default_chemical_groups</code></p>"},{"location":"api/medchem.catalog.html#medchem.catalog.merge_catalogs","title":"<code>merge_catalogs(*catalogs)</code>","text":"<p>Merge several catalogs into a single one</p> <p>Returns:</p> Name Type Description <code>catalog</code> <code>FilterCatalog</code> <p>merged catalog</p>"},{"location":"api/medchem.complexity.html","title":"<code>medchem.rules</code>","text":""},{"location":"api/medchem.complexity.html#medchem.complexity.complexity_filter","title":"<code>medchem.complexity.complexity_filter</code>","text":""},{"location":"api/medchem.complexity.html#medchem.complexity.complexity_filter.ComplexityFilter","title":"<code>ComplexityFilter</code>","text":"<p>Complexity filters derived from nonpher: https://github.com/lich-uct/nonpher/blob/master/nonpher/nonpher.py</p> <p>To recover the original complexity score, use <code>threshold_stats_file = \"zinc_12\"</code>. The threshold have been re-calculated using the original new zinc-15 and focusing only on commercially available compounds.</p>"},{"location":"api/medchem.complexity.html#medchem.complexity.complexity_filter.ComplexityFilter.__call__","title":"<code>__call__(mol)</code>","text":"<p>Check whether the input structure is too complex given this instance of the complexity filter Return False is the molecule is too complex, else True</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>input molecule</p> required"},{"location":"api/medchem.complexity.html#medchem.complexity.complexity_filter.ComplexityFilter.__init__","title":"<code>__init__(limit='99', complexity_metric='bertz', threshold_stats_file='zinc_15_available')</code>","text":"<p>Default complexity limit is set on at least 1 exceeding metric on the 999th permille level</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>str</code> <p>The complexity percentile outlier limit to be used (should be expressed as an integer)</p> <code>'99'</code> <code>complexity_metric</code> <code>str</code> <p>The complexity filter name to be used. Use <code>ComplexityFilter.list_default_available_filters</code> to list default filters. The following complexity metrics are supported by default * \"bertz\": bertz complexity index * \"sas\": synthetic accessibility score  (<code>zinc_15_available</code> only) * \"qed\": qed score  (<code>zinc_15_available</code> only) * \"clogp\": clogp for how greasy a molecule is compared to other in the same mw range  (<code>zinc_15_available</code> only) * \"whitlock\": whitlock complexity index * \"barone\": barone complexity index * \"smcm\": synthetic and molecular complexity * \"twc\":  total walk count complexity  (<code>zinc_15_available</code> only)</p> <code>'bertz'</code> <code>threshold_stats_file</code> <code>Optional[str]</code> <p>The path to or type the threshold file to be used. The default available threshold stats files are * \"zinc_12\" * \"zinc_15_available\"</p> <code>'zinc_15_available'</code>"},{"location":"api/medchem.complexity.html#medchem.complexity.complexity_filter.ComplexityFilter.list_default_available_filters","title":"<code>list_default_available_filters()</code>  <code>classmethod</code>","text":"<p>Return a list of unique filter names</p>"},{"location":"api/medchem.complexity.html#medchem.complexity.complexity_filter.ComplexityFilter.list_default_percentile","title":"<code>list_default_percentile(threshold_stats_file=None)</code>  <code>cached</code> <code>classmethod</code>","text":"<p>Return the default percentile list for the threshold file</p>"},{"location":"api/medchem.complexity.html#medchem.complexity.complexity_filter.ComplexityFilter.load_threshold_stats_file","title":"<code>load_threshold_stats_file(path=None)</code>  <code>classmethod</code>","text":"<p>Load threshold file to compute the percentille depending on the MW for each complexity_metric</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[str]</code> <p>path to the threshold file</p> <code>None</code>"},{"location":"api/medchem.complexity.html#medchem.complexity._complexity_calc","title":"<code>medchem.complexity._complexity_calc</code>","text":"<p>Complexity filters as implemented in nonpher https://github.com/lich-uct/nonpher/blob/master/nonpher/complex_lib.py</p>"},{"location":"api/medchem.complexity.html#medchem.complexity._complexity_calc.BaroneCT","title":"<code>BaroneCT(mol, chiral=False)</code>","text":"<p>Compute a Barone complexity measure for a molecule as described in:</p> <p>R. Barone and M. Chanon, J. Chem. Inf. Comput. Sci., 2001, 41 (2), pp 269\u2013272 Qi Huang, Lin-LiLi, Sheng-Yong Yang, J. Mol. Graph. Model. 2010, 28 (8), pp 775\u2013787</p> <p>Parameter values are hardcoded as in the articles. On zinc 15 commercially available dataset, the range of this score is [30, 4266] with a median of 538</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>The input molecule.</p> required <code>chiral</code> <code>bool</code> <p>Whether to include chirality in the calculation.</p> <code>False</code>"},{"location":"api/medchem.complexity.html#medchem.complexity._complexity_calc.SMCM","title":"<code>SMCM(mol)</code>","text":"<p>Compute synthetic and molecular complexity as described in:</p> <p>TK Allu, TI Oprea, J. Chem. Inf. Model. 2005, 45(5), pp. 1237-1243. https://sci-hub.ee/10.1021/ci0501387</p> <p>On zinc 15 commercially available dataset, the range of this score is [1.93, 192.00] with a median of 42.23</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>the input molecule</p> required"},{"location":"api/medchem.complexity.html#medchem.complexity._complexity_calc.TWC","title":"<code>TWC(mol, log10=True)</code>","text":"<p>Compute total walk count in a molecules as proxy for complexity. This score is described in: <code>twc = 1/2 sum(k=1..n-1,sum(i=atoms,awc(k,i)))</code> Gerta Rucker and Christoph Rucker, J. Chem. Inf. Comput. Sci. 1993, 33, 683-695</p> <p>On zinc 15 commercially available dataset, the range of this score is [1.20, 39.08] with a median of 10.65</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <p>the input molecule</p> required <code>log10</code> <code>bool</code> <p>whether to return the log10 of the values</p> <code>True</code>"},{"location":"api/medchem.complexity.html#medchem.complexity._complexity_calc.WhitlockCT","title":"<code>WhitlockCT(mol, ringval=4, unsatval=2, heteroval=1, chiralval=2)</code>","text":"<p>A chemically intuitive measure for molecular complexity. This complexity measure has been described in : H. W. Whitlock, J. Org. Chem., 1998, 63, 7982-7989. Benzyls, fenyls, etc. are not treated at all.</p> <p>On zinc 15 commercially available dataset, the range of this score is [0, 172] with a median of 25</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <p>The input molecule.</p> required <code>ringval</code> <code>float</code> <p>The contribution of rings</p> <code>4</code> <code>unsatval</code> <code>float</code> <p>The contribution of the unsaturated bond.</p> <code>2</code> <code>heteroval</code> <code>float</code> <p>The contribution of the heteroatom.</p> <code>1</code> <code>chiralval</code> <code>float</code> <p>The contribution of the chiral center.</p> <code>2</code>"},{"location":"api/medchem.demerits.html","title":"<code>medchem.demerits</code>","text":""},{"location":"api/medchem.demerits.html#medchem.demerits","title":"<code>medchem.demerits</code>","text":""},{"location":"api/medchem.demerits.html#medchem.demerits.batch_score","title":"<code>batch_score(smiles_list, n_jobs=None, batch_size=5000, progress=False, **run_options)</code>","text":"<p>Run scorer on input smile list in batch</p> <p>Parameters:</p> Name Type Description Default <code>smiles_list</code> <code>List</code> <p>list of smiles</p> required <code>n_jobs</code> <code>Optional[int]</code> <p>Number of jobs to run in parallel.</p> <code>None</code> <code>batch_size</code> <code>Optional[int]</code> <p>Optional batch_size to run the the scoring in parallels.</p> <code>5000</code> <code>progress</code> <code>bool</code> <p>Whether to show progress bar.</p> <code>False</code> <code>run_options</code> <p>Run options to pass to the underlining score function</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>out_df</code> <code>pd.DataFrame</code> <p>Dataframe containing the smiles and computed properties: (rejected, demerit_score, reason, step)</p>"},{"location":"api/medchem.demerits.html#medchem.demerits.run_cmd","title":"<code>run_cmd(cmd, shell=False)</code>","text":"<p>Run command</p>"},{"location":"api/medchem.demerits.html#medchem.demerits.score","title":"<code>score(smiles_list, mc_first_pass_options='', iwd_options='', stop_after_step=3, **run_options)</code>","text":"<p>Run scorer on input smile list:</p> <p>Parameters:</p> Name Type Description Default <code>smiles_list</code> <code>List</code> <p>list of smiles</p> required <code>mc_first_pass_options</code> <code>Optional[str]</code> <p>Initial options to pass to mc_first_pass</p> <code>''</code> <code>iwd_options</code> <code>Optional[str]</code> <p>Initial options to pass to iwdemerit</p> <code>''</code> <code>stop_after_step</code> <code>Optional[int]</code> <p>Where to stop in the pipeline. Don't change this if you don't know.</p> <code>3</code> <code>run_options</code> <p>Additional option to run the pipeline</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>out_df</code> <code>pd.DataFrame</code> <p>Dataframe containing the smiles and computed properties: (rejected, demerit_score, reason, step)</p>"},{"location":"api/medchem.filter.html","title":"<code>medchem.filter</code>","text":""},{"location":"api/medchem.filter.html#medchem.filter.lead","title":"<code>medchem.filter.lead</code>","text":""},{"location":"api/medchem.filter.html#medchem.filter.lead.alert_filter","title":"<code>alert_filter(mols, alerts, alerts_db=None, n_jobs=1, rule_dict=None, return_idx=False)</code>","text":"<p>Filter a dataset of molecules, based on common structural alerts and specific rules.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, dm.Mol]]</code> <p>List of molecules to filter</p> required <code>alerts</code> <code>List[str]</code> <p>List of alert collections to screen for. See AlertFilters.list_default_available_alerts()</p> required <code>alerts_db</code> <code>Optional[os.PathLike]</code> <p>Path to the alert file name. The internal default file (alerts.csv) will be used if not provided</p> <code>None</code> <code>n_jobs</code> <code>Optional[int]</code> <p>Number of cpu to use</p> <code>1</code> <code>rule_dict</code> <code>Dict</code> <p>Dictionary with additional rules to apply during the filtering. For example, such dictionary for drug-like compounds would look like this:</p> <p>rule_dict     {\"MW\": [0, 500], \"LogP\": [-0.5, 5], \"HBD\": [0, 5], \"HBA\": [0, 10], \"TPSA\": [0, 150]}</p> <code>None</code> <code>return_idx</code> <code>bool</code> <p>Whether to return the filtered index</p> <code>False</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule IS OK (not found in the alert catalog).</p>"},{"location":"api/medchem.filter.html#medchem.filter.lead.bredt_filter","title":"<code>bredt_filter(mols, return_idx=False, n_jobs=None, progress=False, scheduler='threads', batch_size=100)</code>","text":"<p>Filter a list of compounds according to Bredt's rules https://en.wikipedia.org/wiki/Bredt%27s_rule</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'threads'</code> <code>batch_size</code> <code>int</code> <p>batch size for parallel processing. Note that <code>batch_size</code> should be increased if the number of used CPUs gets very large.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule is not toxic.</p>"},{"location":"api/medchem.filter.html#medchem.filter.lead.catalog_filter","title":"<code>catalog_filter(mols, catalogs, return_idx=False, n_jobs=None, progress=False, scheduler='processes', batch_size=100)</code>","text":"<p>Filter a list of compounds according to catalog of structures alerts and patterns</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>catalogs</code> <code>List[Union[str, FilterCatalog]]</code> <p>list of catalogs (name or FilterCatalog)</p> required <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'processes'</code> <code>batch_size</code> <code>int</code> <p>batch size for parallel processing. Note that <code>batch_size</code> should be increased if the number of used CPUs gets very large.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule is not found in the catalog.</p>"},{"location":"api/medchem.filter.html#medchem.filter.lead.chemical_group_filter","title":"<code>chemical_group_filter(mols, chemical_group, return_idx=False, n_jobs=None, progress=False, scheduler='threads')</code>","text":"<p>Filter a list of compounds according to a chemical group instance.</p> <p>Note</p> <p>This function will return the list of molecules that DO NOT match the chemical group</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>chemical_group</code> <code>ChemicalGroup</code> <p>a chemical group instance with the required functional groups to use.</p> required <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'threads'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule DOES NOT MATCH the groups.</p>"},{"location":"api/medchem.filter.html#medchem.filter.lead.complexity_filter","title":"<code>complexity_filter(mols, complexity_metric='bertz', threshold_stats_file='zinc_15_available', limit='99', return_idx=False, n_jobs=None, progress=False, scheduler='processes')</code>","text":"<p>Filter a list of compounds according to a chemical group instance</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>complexity_metric</code> <code>str</code> <p>complexity metric to use Use <code>ComplexityFilter.list_default_available_filters</code> to list default filters. The following complexity metrics are supported by default * \"bertz\": bertz complexity index * \"sas\": synthetic accessibility score  (<code>zinc_15_available</code> only) * \"qed\": qed score  (<code>zinc_15_available</code> only) * \"clogp\": clogp for how greasy a molecule is compared to other in the same mw range  (<code>zinc_15_available</code> only) * \"whitlock\": whitlock complexity index * \"barone\": barone complexity index * \"smcm\": synthetic and molecular complexity * \"twc\":  total walk count complexity  (<code>zinc_15_available</code> only)</p> <code>'bertz'</code> <code>threshold_stats_file</code> <code>str</code> <p>complexity threshold statistic origin to use</p> <code>'zinc_15_available'</code> <code>limit</code> <code>str</code> <p>complexity outlier percentile to use</p> <code>'99'</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'processes'</code> Also see <p>medchem.complexity.ComplexityFilter</p> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule MATCH the rules.</p>"},{"location":"api/medchem.filter.html#medchem.filter.lead.lilly_demerit_filter","title":"<code>lilly_demerit_filter(smiles, max_demerits=160, return_idx=False, n_jobs=None, progress=False, **kwargs)</code>","text":"<p>Run Lilly demerit filtering on current list of molecules</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>Iterable[str]</code> <p>list of input molecules as smiles preferably</p> required <code>max_demerits</code> <code>Optional[int]</code> <p>Cutoff to reject molecules Defaults to 160.</p> <code>160</code> <code>return_idx</code> <code>bool</code> <p>whether to return a mask or a list of valid indexes</p> <code>False</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>kwargs</code> <p>parameters specific to the <code>demerits.score</code> function</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.filter.html#medchem.filter.lead.molecular_graph_filter","title":"<code>molecular_graph_filter(mols, max_severity=5, return_idx=False, n_jobs=None, progress=False, scheduler='threads')</code>","text":"<p>Filter a list of compounds according to unstable molecular graph filter list.</p> <p>This list was obtained from observation around The disallowed graphs are:</p> <ul> <li>K3,3 or K2,4 structure</li> <li>Cone of P4 or K4 with 3-ear</li> <li>Node in more than one ring of length 3 or 4</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>max_severity</code> <code>int</code> <p>maximum acceptable severity (1-10). Default is &lt;5</p> <code>5</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'threads'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule is not toxic.</p>"},{"location":"api/medchem.filter.html#medchem.filter.lead.protecting_groups_filter","title":"<code>protecting_groups_filter(mols, return_idx=False, protecting_groups=['fmoc', 'tert-butoxymethyl', 'tert-butyl carbamate', 'tert-butyloxycarbonyl'], n_jobs=None, progress=False, scheduler='threads')</code>","text":"<p>Filter a list of compounds according to match to  known protecting groups. Note that is a syntaxic sugar for calling chemical_group_filter with the protecting groups subset</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>protecting_groups</code> <code>str</code> <p>type of protection group to consider if not provided, will use all (not advised)</p> <code>['fmoc', 'tert-butoxymethyl', 'tert-butyl carbamate', 'tert-butyloxycarbonyl']</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'threads'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule DOES NOT MATCH the groups.</p>"},{"location":"api/medchem.filter.html#medchem.filter.lead.rules_filter","title":"<code>rules_filter(mols, rules, return_idx=False, n_jobs=None, progress=False, scheduler='processes')</code>","text":"<p>Filter a list of compounds according to a predefined set of rules</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>rules</code> <code>Union[List[Any], RuleFilters]</code> <p>list of rules to apply to the input molecules.</p> required <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'processes'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule MATCH the rules.</p>"},{"location":"api/medchem.filter.html#medchem.filter.lead.screening_filter","title":"<code>screening_filter(mols, n_jobs=None, max_severity=10, return_idx=False)</code>","text":"<p>Filter a set of molecules based on novartis screening deck curation process Schuffenhauer, A. et al. Evolution of Novartis' small molecule screening deck design, J. Med. Chem. (2020) DOI. https://dx.doi.org/10.1021/acs.jmedchem.0c01332</p> <p>Note</p> <p>The severity argument corresponds to the accumulated severity for a compounds accross all pattern in the catalog.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>max_severity</code> <code>int</code> <p>maximum severity allowed. Default is &lt;10</p> <code>10</code> <code>return_idx</code> <code>bool</code> <p>Whether to return the filtered index</p> <code>False</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule IS NOT REJECTED (i.e not found in the alert catalog).</p>"},{"location":"api/medchem.filter.html#medchem.filter.generic","title":"<code>medchem.filter.generic</code>","text":""},{"location":"api/medchem.filter.html#medchem.filter.generic.atom_list_filter","title":"<code>atom_list_filter(mols, unwanted_atom_list=None, wanted_atom_list=None, return_idx=False, n_jobs=None, progress=False, scheduler=None)</code>","text":"<p>Find molecule without any atom from a set of unwanted atom symbols and with all atoms in the set of desirable atom list</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>unwanted_atom_list</code> <code>Optional[Iterable]</code> <p>list of undesirable atom symbol</p> <code>None</code> <code>wanted_atom_list</code> <code>Optional[Iterable]</code> <p>list of desirable atom symbol</p> <code>None</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>Optional[str]</code> <p>joblib scheduler to use</p> <code>None</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.filter.html#medchem.filter.generic.halogenicity_filter","title":"<code>halogenicity_filter(mols, thresh_F=6, thresh_Br=3, thresh_Cl=3, return_idx=False, n_jobs=None, progress=False, scheduler=None)</code>","text":"<p>Find molecule that do not exceed halogen threshold. These thresholds are:</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>thresh_F</code> <code>int</code> <p>maximum number of fluorine</p> <code>6</code> <code>thresh_Br</code> <code>int</code> <p>maximum number of bromine</p> <code>3</code> <code>thresh_Cl</code> <code>int</code> <p>maximum number of chlorine</p> <code>3</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>Optional[str]</code> <p>joblib scheduler to use</p> <code>None</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.filter.html#medchem.filter.generic.macrocycle_filter","title":"<code>macrocycle_filter(mols, max_cycle_size=10, return_idx=False, n_jobs=None, progress=False, scheduler=None)</code>","text":"<p>Find molecules that do not infringe the strict maximum cycle size.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>max_cycle_size</code> <code>int</code> <p>strict maximum macrocycle size</p> <code>10</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>Optional[str]</code> <p>joblib scheduler to use</p> <code>None</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.filter.html#medchem.filter.generic.num_atom_filter","title":"<code>num_atom_filter(mols, min_atoms=None, max_atoms=None, return_idx=False, n_jobs=None, progress=False, scheduler=None)</code>","text":"<p>Find a molecule that match the atom number constraints Returning True means the molecule is fine</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>min_atoms</code> <code>Optional[int]</code> <p>strict minimum number of atoms (atoms &gt; min_atoms)</p> <code>None</code> <code>max_atoms</code> <code>Optional[int]</code> <p>strict maximum number of atoms (atoms &lt; max_atoms)</p> <code>None</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>Optional[str]</code> <p>joblib scheduler to use</p> <code>None</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.filter.html#medchem.filter.generic.num_stereo_center_filter","title":"<code>num_stereo_center_filter(mols, max_stereo_centers=4, max_undefined_stereo_centers=2, return_idx=False, n_jobs=None, progress=False, scheduler=None)</code>","text":"<p>Find a molecule that match the number of stereo center constraints. Returning True means the molecule is fine</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>max_stereo_center</code> <p>strict maximum number of stereo centers (&lt;). Default is 4</p> required <code>max_undefined_stereo_centers</code> <code>Optional[int]</code> <p>strict maximum number of undefined stereo centers (&lt;). Default is 2</p> <code>2</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>Optional[str]</code> <p>joblib scheduler to use</p> <code>None</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.filter.html#medchem.filter.generic.ring_infraction_filter","title":"<code>ring_infraction_filter(mols, hetcycle_min_size=4, return_idx=False, n_jobs=None, progress=False, scheduler=None)</code>","text":"<p>Find molecules that have a ring infraction filter. Returning True means the molecule is fine</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>hetcycle_min_size</code> <code>int</code> <p>Minimum ring size before more than 1 hetero atom or any non single bond is allowed. This is a strict threshold (&gt;)</p> <code>4</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>Optional[str]</code> <p>joblib scheduler to use</p> <code>None</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.filter.html#medchem.filter.generic.symmetry_filter","title":"<code>symmetry_filter(mols, symmetry_threshold=0.8, return_idx=False, n_jobs=None, progress=False, scheduler=None)</code>","text":"<p>Find molecules that are not symmetrical, given a symmetry threshold</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Iterable[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>symmetry_threshold</code> <code>float</code> <p>threshold to consider a molecule highly symmetrical</p> <code>0.8</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>Optional[str]</code> <p>joblib scheduler to use</p> <code>None</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.groups.html","title":"<code>medchem.groups</code>","text":""},{"location":"api/medchem.groups.html#medchem.groups","title":"<code>medchem.groups</code>","text":""},{"location":"api/medchem.groups.html#medchem.groups.ChemicalGroup","title":"<code>ChemicalGroup</code>","text":"<p>Build a library of chemical groups using a list of structures parsed from a file</p> <p>The default library of structure has been curated from https://github.com/Sulstice/global-chem and additional open source data.</p> <p>Note</p> <p>For new chemical groups, please minimally provide the 'smiles'/'smarts', 'name' and \"group\" and optional 'hierarchy' columns</p> <p>Warning</p> <p>The SMILES and SMARTS used in the default list of substructures do not result in the same matches. Unless specified otherwise, the SMILES will be used in the matching done by this class, whereas due to RDKit's limitation, the SMARTS will be used in the matching done by the generated catalog. For more information see this discussion: https://github.com/valence-platform/medchem/pull/19,</p>"},{"location":"api/medchem.groups.html#medchem.groups.ChemicalGroup.dataframe","title":"<code>dataframe</code>  <code>property</code>","text":"<p>Get the dataframe of the chemical groups</p>"},{"location":"api/medchem.groups.html#medchem.groups.ChemicalGroup.mol_smarts","title":"<code>mol_smarts</code>  <code>property</code>","text":"<p>Get the SMARTS of the chemical groups in this instance</p>"},{"location":"api/medchem.groups.html#medchem.groups.ChemicalGroup.mols","title":"<code>mols</code>  <code>property</code>","text":"<p>Get the Molecule object of the SMILES for the chemical groups in this instance</p>"},{"location":"api/medchem.groups.html#medchem.groups.ChemicalGroup.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the Name of the chemical groups in this instance</p>"},{"location":"api/medchem.groups.html#medchem.groups.ChemicalGroup.smarts","title":"<code>smarts</code>  <code>property</code>","text":"<p>Get the SMARTS of the chemical groups in this instance</p>"},{"location":"api/medchem.groups.html#medchem.groups.ChemicalGroup.smiles","title":"<code>smiles</code>  <code>property</code>","text":"<p>Get the SMILES of the chemical groups in this instance</p>"},{"location":"api/medchem.groups.html#medchem.groups.ChemicalGroup.__init__","title":"<code>__init__(groups=None, n_jobs=None, groups_db=None)</code>","text":"<p>Build a chemical group library</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>Union[str, List[str]]</code> <p>List of groups to use. Defaults to None where all functional groups are used</p> <code>None</code> <code>n_jobs</code> <code>Optional[int]</code> <p>Optional number of jobs to run in parallel for internally building the data. Defaults to None.</p> <code>None</code> <code>groups_db</code> <code>Optional[os.PathLike]</code> <p>Path to a file containing the dump of the chemical groups. Defaults is internal dataset</p> <code>None</code>"},{"location":"api/medchem.groups.html#medchem.groups.ChemicalGroup.filter","title":"<code>filter(names, fuzzy=False)</code>","text":"<p>Filter the group to restrict to only the name in input</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>List[str]</code> <p>list of names to use for filters</p> required <code>fuzzy</code> <code>bool</code> <p>whether to use exact of fuzzy matching</p> <code>False</code>"},{"location":"api/medchem.groups.html#medchem.groups.ChemicalGroup.get_catalog","title":"<code>get_catalog()</code>  <code>cached</code>","text":"<p>Build an rdkit catalog from the current chemical group data</p>"},{"location":"api/medchem.groups.html#medchem.groups.ChemicalGroup.get_matches","title":"<code>get_matches(mol, use_smiles=True)</code>","text":"<p>Get all the functional groups in this instance that matches the input molecule</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>use_smiles</code> <code>bool</code> <p>whether to use the smiles representation of the catalog or the smarts</p> <code>True</code>"},{"location":"api/medchem.groups.html#medchem.groups.ChemicalGroup.has_match","title":"<code>has_match(mol)</code>","text":"<p>Check whether the input molecule has any functional group in this instance</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required"},{"location":"api/medchem.groups.html#medchem.groups.ChemicalGroup.list_groups","title":"<code>list_groups()</code>","text":"<p>List all the chemical groups available</p>"},{"location":"api/medchem.groups.html#medchem.groups.ChemicalGroup.list_hierarchy_groups","title":"<code>list_hierarchy_groups()</code>","text":"<p>List all the hierarchy in chemical groups available. To get the full hierarchy on each path, split by the <code>.</code> character.</p>"},{"location":"api/medchem.groups.html#medchem.groups.list_default_chemical_groups","title":"<code>list_default_chemical_groups(hierachy=False)</code>","text":"<p>List all the chemical groups available.</p> <p>Note</p> <p>chemical groups defines how a collection of patterns are organized. They do not correspond to individual pattern name.</p> <p>Parameters:</p> Name Type Description Default <code>hierarchy</code> <p>whether to return the full hierarchy or the group name only</p> required <p>Returns:</p> Type Description <p>List of chemical groups</p>"},{"location":"api/medchem.groups.html#medchem.groups.list_functional_group_names","title":"<code>list_functional_group_names(exclude_basic=True)</code>","text":"<p>List common functional group names</p> <p>Parameters:</p> Name Type Description Default <code>exclude_basic</code> <code>bool</code> <p>whether to include the basic functional groups</p> <code>True</code> <p>Returns:</p> Type Description <p>List of functional group names</p>"},{"location":"api/medchem.query.html","title":"<code>medchem.query</code>","text":"<p>This module helps build a filter based on a query language that can be parsed.  By default, the default query parser will be used, which contains the following instructions that can be orchestrated using boolean operation (<code>or</code>, <code>and</code>, <code>not</code> and parenthesis)</p>"},{"location":"api/medchem.query.html#example","title":"Example","text":"<pre><code>import datamol as dm\nfrom medchem.query.eval import QueryFilter\n\nquery = \"\"\"HASPROP(\"tpsa\" &lt; 120) AND HASSUBSTRUCTURE(\"[OH]\", True)\"\"\"\nchemical_filter = QueryFilter(query, parser=\"lalr\")\nmols = dm.data.cdk2().mol[:10]\nchemical_filter(mols, n_jobs=-1) # [False, False, False, False, False, True, True, True, False, False]\n</code></pre>"},{"location":"api/medchem.query.html#syntax","title":"Syntax","text":"<p>Any string provided as <code>query</code> argument needs to be quoted (similar to json) to avoid ambiguity in parsing.  * An example of valid query is <code>\"\"\"(HASPROP(\"tpsa\" &gt; 120 ) | HASSUBSTRUCTURE(\"c1ccccc1\")) AND NOT HASALERT(\"pains\") OR HASSUBSTRUCTURE(\"[OH]\", max, 2)\"\"\"</code>. * Examples of invalid queries are    * <code>\"\"\"HASPROP(\"tpsa\" &gt; 120) OR HASSUBSTRUCTURE(\"[OH]\", True, &gt;, 3)\"\"\"</code> : unexpected wrong operator <code>&gt;</code>   * <code>\"\"\"HASPROP(tpsa &gt; 120)\"\"\"</code> : tpsa is not quoted   * <code>\"\"\"HASPROP(\"tpsa\") &gt; 120\"\"\"</code> : this is not part of the language specification   * <code>\"\"\"(HASPROP(\"tpsa\" &gt; 120) AND HASSUBSTRUCTURE(\"[OH]\", True, max, 3 )\"\"\"</code>: mismatching parenthesis <code>(</code></p> <ul> <li><code>\"\"\"HASPROP(\"tpsa\" &gt; 120) OR HASSUBSTRUCTURE(\"CO\")\"\"\"</code>, <code>\"\"\"(HASPROP(\"tpsa\" &gt; 120)) OR (HASSUBSTRUCTURE(\"CO\"))\"\"\"</code> and <code>\"\"\"(HASPROP(\"tpsa\" &gt; 120) OR HASSUBSTRUCTURE(\"CO\"))\"\"\"</code> are equivalent</li> </ul>"},{"location":"api/medchem.query.html#hasalert","title":"HASALERT","text":"<p>check whether a molecule has an <code>alert</code> from a catalog <pre><code># alert is one supported alert catalog by `medchem`. For example `pains`\nHASALERT(alert:str) \n</code></pre></p>"},{"location":"api/medchem.query.html#hasgroup","title":"HASGROUP","text":"<p>check whether a molecule has a specific functional group from a catalog</p> <pre><code># group is one supported functional group provided by `medchem`\nHASGROUP(group:str) \n</code></pre>"},{"location":"api/medchem.query.html#matchrule","title":"MATCHRULE","text":"<p>check whether a molecule match a predefined druglikeness <code>rule</code> from a catalog <pre><code># rule is one supported rule provided by `medchem`. For example `rule_of_five`\nMATCHRULE(rule:str) \n</code></pre></p>"},{"location":"api/medchem.query.html#hassuperstructure","title":"HASSUPERSTRUCTURE","text":"<p>check whether a molecule has <code>query</code> as superstructure <pre><code># query is a SMILES\nHASSUPERSTRUCTURE(query:str) \n</code></pre></p>"},{"location":"api/medchem.query.html#hassubstructure","title":"HASSUBSTRUCTURE","text":"<p>Check whether a molecule has <code>query</code> as substructure.  Note that providing the comma separator <code>,</code> is mandatory here as each variable is an argument.</p> <pre><code># query is a SMILES or a SMARTS, operator is defined below, is_smarts is a boolean\n\nHASSUBSTRUCTURE(query:str, is_smarts:Optional[bool], operator:Optional[str], limit:Optional[int])\n\n# which correspond to setting this default values\nHASSUBSTRUCTURE(query:str, is_smarts=False, operator=\"min\", limit=1)\n# same as\nHASSUBSTRUCTURE(query:str, is_smarts=None, operator=None, limit=None)\n</code></pre> <p>Not providing optional arguments is allowed, but they need to be provided in the exact same order shown above. Thus:</p> <ul> <li><code>HASSUBSTRUCTURE(\"CO\")</code></li> <li><code>HASSUBSTRUCTURE(\"CO\", False)</code></li> <li><code>HASSUBSTRUCTURE(\"CO\", False, min)</code></li> <li><code>HASSUBSTRUCTURE(\"CO\", False, min, 1)</code></li> </ul> <p>are all <code>valid</code> and <code>equivalent</code> (given their default values)</p> <p>Furthermore, since the correct argument map can be inferred when no ambiguity arises, the following <code>are valid but discouraged</code></p> <ul> <li><code>HASSUBSTRUCTURE(\"CO\", False, 1)</code></li> <li><code>HASSUBSTRUCTURE(\"CO\", min, 1)</code></li> </ul> <p>Whereas, this is invalid: * <code>HASSUBSTRUCTURE(\"CO\", min, False, 1)</code></p>"},{"location":"api/medchem.query.html#hasprop","title":"HASPROP","text":"<p>Check whether a molecule has <code>prop</code> as property within a defined limit. Any comma <code>,</code> provided between arguments will be ignored</p> <pre><code># prop is a valid datamol.descriptors property, comparator is a required comparator operator and defined below\nHASPROP(prop:str comparator:str limit:float)\n</code></pre>"},{"location":"api/medchem.query.html#like","title":"LIKE","text":"<p>Check whether a molecule is similar enough to another molecule. Any comma <code>,</code> provided between arguments will be ignored</p> <pre><code># query is a SMILES\nLIKE(query:str  comparator:str limit:float)\n</code></pre>"},{"location":"api/medchem.query.html#basic-operators","title":"Basic operators:","text":"<ul> <li>comparator: one of <code>=</code> <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>,  <code>&gt;=</code></li> <li>misc: the following misc values are accepted and parsed <code>true</code>, <code>false</code>, <code>True</code>, <code>False</code>, <code>TRUE</code>, <code>FALSE</code></li> <li>operator (can be quoted or unquoted):</li> <li>MIN: <code>min</code>, <code>MIN</code></li> <li>MAX: <code>max</code>, <code>MAX</code></li> <li>boolean operator: </li> <li>AND operator : <code>AND</code> or <code>&amp;</code> or <code>&amp;&amp;</code> or <code>and</code></li> <li>OR operator : <code>OR</code>  or <code>|</code> or <code>||</code> or <code>or</code></li> <li>NOT operator : <code>NOT</code> or  <code>!</code> or  <code>~</code> or <code>not</code></li> </ul>"},{"location":"api/medchem.query.html#api","title":"API","text":""},{"location":"api/medchem.query.html#medchem.query.parser","title":"<code>medchem.query.parser</code>","text":""},{"location":"api/medchem.query.html#medchem.query.parser.QueryParser","title":"<code>QueryParser</code>","text":"<p>         Bases: <code>Transformer</code></p> <p>Query parser for the custom query language for molecule. This parses the input language, build a parseable and evaluable representation. The trick for lazy evaluation is to define custom guard with '<code>fn(*)</code>' around expression that needs to be evaluated.</p> <p>Note that you SHOULD NOT HAVE TO INTERACT WITH THIS CLASS DIRECTLY.</p> Example <p>import medchem import lark QUERY_GRAMMAR = medchem.utils.loader.get_grammar(as_string=True) QUERY_PARSER = Lark(QUERY_GRAMMAR, parser=\"lalr\", transformer=QueryParser())</p>"},{"location":"api/medchem.query.html#medchem.query.parser.QueryParser--see-how-the-string-needs-to-be-quoted-this-builds-on-the-json-quote-requirements-to-avoid-dealing-with-unwanted-outcomes","title":"see how the string needs to be \"quoted\". This builds on the json quote requirements to avoid dealing with unwanted outcomes","text":"<p>example = \"\"\"(HASPROP(\"tpsa\" &gt; 120 ) | HASSUBSTRUCTURE(\"c1ccccc1\")) AND NOT HASALERT(\"pains\") OR HASSUBSTRUCTURE(\"[OH]\", max)\"\"\" t = QUERY_PARSER.parse(example) print(t) ((((<code>fn(getprop, prop='tpsa')</code> &gt; 120.0) or <code>fn(hassubstructure, query='c1ccccc1', operator='None', limit=None, is_smarts=None)</code>) and not <code>fn(hasalert, alert='pains')</code>) or <code>fn(hassubstructure, query='[OH]', operator='max', limit=None, is_smarts=None)</code>)</p>"},{"location":"api/medchem.query.html#medchem.query.parser.QueryParser.bool_expr","title":"<code>bool_expr(bool_term, *others)</code>","text":"<p>Define how boolean expressions should be parsed</p>"},{"location":"api/medchem.query.html#medchem.query.parser.QueryParser.bool_term","title":"<code>bool_term(bool_factor, *others)</code>","text":"<p>Define how boolean terms should be parsed</p>"},{"location":"api/medchem.query.html#medchem.query.parser.QueryParser.hasalert","title":"<code>hasalert(value)</code>","text":"<p>Format the hasalert node in the query</p> <p>Note</p> <p>The parser does not enforce any validity on the argument and the underlying function is supposed to handle it.</p>"},{"location":"api/medchem.query.html#medchem.query.parser.QueryParser.hasgroup","title":"<code>hasgroup(value)</code>","text":"<p>Format the hasgroup node in the query</p> <p>Note</p> <p>The parser does not enforce any validity on the argument and the underlying function is supposed to handle it.</p>"},{"location":"api/medchem.query.html#medchem.query.parser.QueryParser.hasprop","title":"<code>hasprop(value, comparator, limit)</code>","text":"<p>Format the hasprop node in the query</p> <p>Note</p> <p>The parser does not enforce any validity on the argument and the underlying function is supposed to handle it.</p>"},{"location":"api/medchem.query.html#medchem.query.parser.QueryParser.hassubstructure","title":"<code>hassubstructure(value, is_smarts, operator, limit)</code>","text":"<p>Format the substructure node in the query</p> <p>Note</p> <p>The parser does not enforce any validity on the argument and the underlying function is supposed to handle it.</p>"},{"location":"api/medchem.query.html#medchem.query.parser.QueryParser.hassuperstructure","title":"<code>hassuperstructure(value)</code>","text":"<p>Format the superstructure node in the query</p> <p>Note</p> <p>The parser does not enforce any validity on the argument and the underlying function is supposed to handle it.</p>"},{"location":"api/medchem.query.html#medchem.query.parser.QueryParser.like","title":"<code>like(value, comparator, limit)</code>","text":"<p>Format the like node in the query</p> <p>Note</p> <p>The parser does not enforce any validity on the argument and the underlying function is supposed to handle it.</p>"},{"location":"api/medchem.query.html#medchem.query.parser.QueryParser.matchrule","title":"<code>matchrule(value)</code>","text":"<p>Format the matchrule node in the query</p> <p>Note</p> <p>The parser does not enforce any validity on the argument and the underlying function is supposed to handle it.</p>"},{"location":"api/medchem.query.html#medchem.query.parser.QueryParser.not_bool_factor","title":"<code>not_bool_factor(*args)</code>","text":"<p>Define representation of a negation</p>"},{"location":"api/medchem.query.html#medchem.query.eval","title":"<code>medchem.query.eval</code>","text":""},{"location":"api/medchem.query.html#medchem.query.eval.QueryFilter","title":"<code>QueryFilter</code>","text":"<p>Query filtering system based on a custom query grammar</p>"},{"location":"api/medchem.query.html#medchem.query.eval.QueryFilter.__call__","title":"<code>__call__(mols, scheduler='processes', n_jobs=-1, progress=True)</code>","text":"<p>Call the internal chemical filter that has been build</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>List[Union[str, dm.Mol]]</code> <p>list of input molecules to filter</p> required <code>n_jobs</code> <code>int</code> <p>whether to run job in parallel and number of jobs to consider. Defaults to -1.</p> <code>-1</code> <code>scheduler</code> <p>scheduler to use. Defaults to 'processes'.</p> <code>'processes'</code> <code>progress</code> <code>bool</code> <p>whether to show job progress. Defaults to True.</p> <code>True</code>"},{"location":"api/medchem.query.html#medchem.query.eval.QueryFilter.__init__","title":"<code>__init__(query, grammar=None, parser='lalr')</code>","text":"<p>Constructor for query filtering system</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>input unparsed query</p> required <code>grammar</code> <code>Optional[str]</code> <p>path to grammar language to use. Defaults to None, which will use the default grammar.</p> <code>None</code> <code>parser</code> <code>str</code> <p>which Lark language parser to use. Defaults to \"lalr\".</p> <code>'lalr'</code>"},{"location":"api/medchem.query.html#medchem.query.eval.QueryOperator","title":"<code>QueryOperator</code>","text":"<p>A class to hold all the operators that can be used in queries</p>"},{"location":"api/medchem.query.html#medchem.query.eval.QueryOperator.getprop","title":"<code>getprop(mol, prop)</code>  <code>staticmethod</code>","text":"<p>Compute the molecular property if a molecule. This is an alternative to the hasprop function, that does not enforce any comparison.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>prop</code> <code>str</code> <p>molecular property to apply as filter on the molecule</p> required <p>Returns:</p> Name Type Description <code>property</code> <code>float</code> <p>computed property value</p>"},{"location":"api/medchem.query.html#medchem.query.eval.QueryOperator.hasalert","title":"<code>hasalert(mol, alert)</code>  <code>staticmethod</code>","text":"<p>Check if a molecule match a named alert catalog. The alert catalog needs to be one supported by the medchem package.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>alert</code> <code>str</code> <p>named catalog to apply as filter on the molecule</p> required <p>Returns:</p> Name Type Description <code>has_alert</code> <code>bool</code> <p>whether the molecule has a given alert</p>"},{"location":"api/medchem.query.html#medchem.query.eval.QueryOperator.hasgroup","title":"<code>hasgroup(mol, group)</code>  <code>staticmethod</code>","text":"<p>Check if a molecule has a specific functional group. Internally, this is done fetching the smarts corresponding to the group then calling <code>QueryOperator.hassubstructure</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>group</code> <code>str</code> <p>functional group to check on the molecule.</p> required <p>Returns:</p> Name Type Description <code>has_group</code> <code>bool</code> <p>whether the molecule has the given functional group</p>"},{"location":"api/medchem.query.html#medchem.query.eval.QueryOperator.hasprop","title":"<code>hasprop(mol, prop, comparator, limit)</code>  <code>staticmethod</code>","text":"<p>Check if a molecule has a molecule property within desired range</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>prop</code> <code>str</code> <p>molecular property to apply as filter on the molecule</p> required <code>comparator</code> <code>Callable</code> <p>operator function to apply to check whether the molecule property matches the expected value</p> required <code>limit</code> <code>float</code> <p>limit value for determining whether the molecule property is within desired range</p> required <p>Returns:</p> Name Type Description <code>has_property</code> <code>bool</code> <p>whether the molecule has a given property within a desired range</p>"},{"location":"api/medchem.query.html#medchem.query.eval.QueryOperator.hassubstructure","title":"<code>hassubstructure(mol, query, is_smarts=False, operator='min', limit=1)</code>  <code>staticmethod</code>","text":"<p>Check if a molecule has substructure provided by a query</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>query</code> <code>str</code> <p>input smarts query</p> required <code>is_smarts</code> <code>bool</code> <p>whether this is a smarts query or not</p> <code>False</code> <code>operator</code> <code>str</code> <p>one of min or max to specify the min or max limit</p> <code>'min'</code> <code>limit</code> <code>int</code> <p>limit of substructures to be found</p> <code>1</code> <p>Returns:</p> Name Type Description <code>has_substructure</code> <code>bool</code> <p>whether the query is a subgraph of the molecule</p>"},{"location":"api/medchem.query.html#medchem.query.eval.QueryOperator.hassuperstructure","title":"<code>hassuperstructure(mol, query)</code>  <code>staticmethod</code>","text":"<p>Check if a molecule has a superstructure defined by a query. Note that a superstructure cannot be a query (smarts)</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>query</code> <code>str</code> <p>input smarts query</p> required <p>Returns:</p> Name Type Description <code>has_superstructure</code> <code>bool</code> <p>whether the molecule is a subgraph of the query</p>"},{"location":"api/medchem.query.html#medchem.query.eval.QueryOperator.like","title":"<code>like(mol, query, comparator, limit)</code>  <code>staticmethod</code>","text":"<p>Check if a molecule is similar or distant enough from another molecule using tanimoto ECFP distance. and is useful for letting python handles the binary comparison operators.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>query</code> <code>Union[dm.Mol, str]</code> <p>input molecule to compare with</p> required <code>comparator</code> <code>Callable[[float, float], bool]</code> <p>operator function to apply to check whether the molecule property matches the expected value. Takes computed_similarity and <code>limit</code> as arguments and returns a boolean.</p> required <code>limit</code> <code>float</code> <p>limit value for determining whether the molecule property is within desired range</p> required <p>Returns:</p> Name Type Description <code>is_similar</code> <code>bool</code> <p>whether the molecule is similar or distant enough from the query</p>"},{"location":"api/medchem.query.html#medchem.query.eval.QueryOperator.matchrule","title":"<code>matchrule(mol, rule)</code>  <code>staticmethod</code>","text":"<p>Check if a molecule match a druglikeness rule</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>rule</code> <code>str</code> <p>druglikeness rule check on the molecule.</p> required <p>Returns:</p> Name Type Description <code>match_rule</code> <code>bool</code> <p>whether the molecule match the given rule</p>"},{"location":"api/medchem.query.html#medchem.query.eval.QueryOperator.similarity","title":"<code>similarity(mol, query)</code>  <code>staticmethod</code>","text":"<p>Compute the ECFP tanimoto similarity between two molecules. This is an alternative to the like function, that does not enforce any comparison, and is useful for letting python handles the binary comparison operators.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>query</code> <code>Union[dm.Mol, str]</code> <p>input query molecule to compute similarity against</p> required <p>Returns:</p> Name Type Description <code>similarity</code> <code>float</code> <p>computed similarity value between mol and query</p>"},{"location":"api/medchem.rules.html","title":"<code>medchem.rules</code>","text":""},{"location":"api/medchem.rules.html#medchem.rules.basic_rules","title":"<code>medchem.rules.basic_rules</code>","text":""},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_chemaxon_druglikeness","title":"<code>rule_of_chemaxon_druglikeness(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, n_rotatable_bonds=None, n_rings=None, **kwargs)</code>","text":"<p>Compute the drug likeness filter according to chemaxon:</p> <p>It computes: <code>MW &lt; 400 &amp; logP &lt; 5 &amp; HBA &lt;= 10 &amp; HBD &lt;= 5 &amp; ROTBONDS &lt; 5 &amp; ring &gt; 0</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds in the molecule. Defaults to None.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecule. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>roc</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_cns","title":"<code>rule_of_cns(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, tpsa=None, **kwargs)</code>","text":"<p>Computes drug likeness rule for CNS penetrant molecules as described in: Jeffrey &amp; Summerfield (2010) Assessment of the blood-brain barrier in CNS drug discovery.</p> <p>It computes: <code>MW in [135, 582]  &amp; logP in [-0.2, 6.1] &amp; TPSA in [3, 118] &amp; HBD &lt;= 3 &amp; HBA &lt;= 5</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed logP. Defaults to None.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <code>tpsa</code> <code>Optional[int]</code> <p>precomputed TPSA. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>roc</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_druglike_soft","title":"<code>rule_of_druglike_soft(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, tpsa=None, n_rotatable_bonds=None, n_rings=None, n_hetero_atoms=None, charge=None, **kwargs)</code>","text":"<p>Compute the DrugLike Soft rule available in FAF-Drugs4. The rules are described at https://fafdrugs4.rpbs.univ-paris-diderot.fr/filters.html</p> <p>It computes: <pre><code>MW in [100, 600] &amp; logP &lt; in [-3, 6] &amp; HBD &lt;= 7 &amp; HBA &lt;= 12 &amp; TPSA &lt;=180 &amp; ROTBONDS &lt;= 11 &amp;\nRIGBONDS &lt;= 30 &amp; N_RINGS &lt;= 6 &amp; MAX_SIZE_RING &lt;= 18 &amp; N_CARBONS in [3, 35] &amp;  N_HETEROATOMS in [1, 15] &amp;\nHC_RATIO in [0.1, 1.1] &amp; CHARGE in [-4, 4] &amp; N_ATOM_CHARGE &lt;= 4\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA. Defaults to None.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds. Defaults to None.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecules. Defaults to None.</p> <code>None</code> <code>n_hetero_atoms</code> <code>Optional[int]</code> <p>precomputed number of heteroatoms. Defaults to None.</p> <code>None</code> <code>charge</code> <code>Optional[float]</code> <p>precomputed charge. Defaults to None.</p> <code>None</code>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_egan","title":"<code>rule_of_egan(mol, clogp=None, tpsa=None, **kwargs)</code>","text":"<p>Compute passive intestinal absorption according to Egan Rules as described in: Egan, William J., Kenneth M. Merz, and John J. Baldwin (2000) Prediction of drug absorption using multivariate statistics</p> <p>It computes: <code>TPSA in [0, 132] &amp; logP in [-1, 6]</code></p> <p>Note</p> <p>The author built a multivariate statistics model of passive intestinal absorption with robust outlier detection. Outliers were identified as being actively transported. They chose PSA and AlogP98 (cLogP), based on consideration of the physical processes involved in membrane permeability and the interrelationships and redundancies between other available descriptors. Compounds, which had been assayed for Caco-2 cell permeability, demonstrated a good rate of successful predictions (74\u221292%)</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>roe</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_five","title":"<code>rule_of_five(mol, mw=None, clogp=None, n_lipinski_hbd=None, n_lipinski_hba=None, **kwargs)</code>","text":"<p>Compute the Lipinski's rule-of-5 for a molecule. Also known as Pfizer's rule of five or RO5, this rule is a rule of thumb to evaluate the druglikeness of a chemical compounds</p> <p>It computes: <code>MW &lt;= 500 &amp; logP &lt;= 5  &amp; HBD &lt;= 5 &amp; HBA &lt;= 10</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>n_lipinski_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <code>n_lipinski_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ro5</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_five_beyond","title":"<code>rule_of_five_beyond(mol, mw=None, clogp=None, n_hbd=None, n_hba=None, tpsa=None, n_rotatable_bonds=None, **kwargs)</code>","text":"<p>Compute the Beyond rule-of-5 rule for a molecule. This rule illustrates the potential of compounds far beyond rule of 5 space to modulate novel and difficult target classes that have large, flat, and groove-shaped binding sites and has been described in:</p> <p>Doak, Bradley C., et al. (2015) How Beyond Rule of 5 Drugs and Clinical Candidates Bind to Their Targets.</p> <p>It computes: <code>MW &lt;= 1000 &amp; logP in [-2, 10] &amp; HBD &lt;= 6 &amp; HBA &lt;= 15 &amp; TPSA &lt;=250 &amp; ROTBONDS &lt;= 20</code></p> <p>Note</p> <p>This is a very permissive rule and is likely to not be a good predictor for druglikeness as known for small molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA. Defaults to None.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ro5</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_four","title":"<code>rule_of_four(mol, mw=None, clogp=None, n_hba=None, n_rings=None, **kwargs)</code>","text":"<p>Compute the rule-of-4 for a molecule. The rule-of-4 define a rule of thumb for PPI inhibitors, which are typically larger and more lipophilic than inhibitors of more standard binding sites. It has been published in:</p> <p>Morelli X, Bourgeas R, Roche P. (2011) Chemical and structural lessons from recent successes in protein\u2013protein interaction inhibition. Also see: Shin et al. (2020) Current Challenges and Opportunities in Designing Protein\u2013Protein Interaction Targeted Drugs. doi:10.2147/AABC.S235542</p> <p>It computes: <code>MW &gt;= 400 &amp; logP &gt;= 4  &amp; RINGS &gt;=4 &amp; HBA &gt;= 4</code></p> <p>Warning</p> <p>Do not use this for small molecules that are not PPI inhibitors</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecules. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ro4</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_generative_design","title":"<code>rule_of_generative_design(mol, mw=None, clogp=None, n_lipinski_hba=None, n_lipinski_hbd=None, tpsa=None, n_rotatable_bonds=None, n_hetero_atoms=None, charge=None, **kwargs)</code>","text":"<p>Compute druglikeness rule of generative design.</p> <p>This set of rules are proprietary of Valence Discovery and have been curated to better filters molecules suggested by generative models for small molecules</p> <p>It computes:</p> <pre><code>MW in [200, 600] &amp; logP &lt; in [-3, 6] &amp; HBD &lt;= 7  &amp; HBA &lt;= 12 &amp; TPSA in [40, 180] &amp;\nROTBONDS &lt;= 15 &amp; RIGID BONDS &lt;= 30 &amp; N_AROMATIC_RINGS &lt;= 5 &amp; N_FUSED_AROMATIC_RINGS_TOGETHER &lt;= 2 &amp;\nMAX_SIZE_RING_SYSTEM &lt;= 18  &amp; N_CARBONS in [3, 40] &amp; N_HETEROATOMS in [1, 15] &amp; CHARGE in [-2, 2] &amp;\nN_ATOM_CHARGE &lt;= 2 &amp; N_TOTAL_ATOMS &lt; 70 &amp; N_HEAVY_METALS &lt; 1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>n_lipinski_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>n_lipinski_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA. Defaults to None.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds. Defaults to None.</p> <code>None</code> <code>n_hetero_atoms</code> <code>Optional[int]</code> <p>precomputed number of heteroatoms. Defaults to None.</p> <code>None</code> <code>charge</code> <code>Optional[float]</code> <p>precomputed charge. Defaults to None.</p> <code>None</code>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_generative_design_strict","title":"<code>rule_of_generative_design_strict(mol, mw=None, clogp=None, n_lipinski_hba=None, n_lipinski_hbd=None, tpsa=None, n_rotatable_bonds=None, n_hetero_atoms=None, charge=None, **kwargs)</code>","text":"<p>Compute druglikeness rule of generative design.</p> <p>This set of rules are proprietary of Valence Discovery and have been curated to better filters molecules suggested by generative models</p> <p>It computes:</p> <pre><code>MW in [200, 600] &amp; logP &lt; in [-3, 6] &amp; HBD &lt;= 7  &amp; HBA &lt;= 12 &amp; TPSA in [40, 180] &amp;\nROTBONDS &lt;= 15 &amp; RIGID BONDS &lt;= 30 &amp; N_AROMATIC_RINGS &lt;= 5 &amp; N_FUSED_AROMATIC_RINGS_TOGETHER &lt;= 2 &amp;\nMAX_SIZE_RING_SYSTEM &lt;= 18  &amp; N_CARBONS in [3, 40] &amp; N_HETEROATOMS in [1, 15] &amp; CHARGE in [-2, 2] &amp;\nN_ATOM_CHARGE &lt;= 2 &amp; N_TOTAL_ATOMS &lt; 70 &amp; N_HEAVY_METALS &lt; 1 &amp; N_STEREO_CENTER &lt;= 3 &amp;\nHAS_NO_SPIDER_SIDE_CHAINS &amp; FRACTION_RING_SYSTEM &gt;= 0.25\n</code></pre> <p>By default SPIDER_SIDE_CHAINS are defined as having at least 2 'chains' of  &gt;=4 consecutif atoms in side chains (not part of any ring system)</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>n_lipinski_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>n_lipinski_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA. Defaults to None.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds. Defaults to None.</p> <code>None</code> <code>n_hetero_atoms</code> <code>Optional[int]</code> <p>precomputed number of heteroatoms. Defaults to None.</p> <code>None</code> <code>charge</code> <code>Optional[float]</code> <p>precomputed charge. Defaults to None.</p> <code>None</code>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_ghose","title":"<code>rule_of_ghose(mol, mw=None, clogp=None, mr=None, **kwargs)</code>","text":"<p>Compute the Ghose filter. The Ghose filter is a drug-like filter described in: Ghose, AK.; Viswanadhan, VN.; Wendoloski JJ. (1999) A knowledge-based approach in designing combinatorial or medicinal chemistry libraries for drug discovery.1. A qualitative and quantitative characterization of known drug databases.</p> <p>It computes: <code>MW in [160, 480] &amp; logP in [-0.4, 5.6] &amp; Natoms in [20, 70] &amp; refractivity in [40, 130]</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>mr</code> <code>Optional[float]</code> <p>precomputed molecule refractivity. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>rog</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_gsk_4_400","title":"<code>rule_of_gsk_4_400(mol, mw=None, clogp=None, **kwargs)</code>","text":"<p>Compute GSK Rule (4/400) for druglikeness using interpretable ADMET rule of thumb based on Gleeson, M. Paul (2008). Generation of a set of simple, interpretable ADMET rules of thumb.</p> <p>It computes: <code>MW &lt;= 400 &amp; logP &lt;= 4</code>.</p> <p>Note</p> <ul> <li>The rule are based on a set of consistent structure-property guides determined from an analysis of a number of key     ADMET assays run within GSK: solubility, permeability, bioavailability, volume of distribution, plasma protein binding,     CNS penetration, brain tissue binding, P-gp efflux, hERG inhibition, and cytochrome P450 1A2/2C9/2C19/2D6/3A4 inhibition.</li> <li>Conclusion: It is clear from the analyses reported herein that almost all ADMET parameters deteriorate with either increasing molecular weight,     logP, or both, with ionization state playing either a beneficial or detrimental affect depending on the parameter in question.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>rog</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_leadlike_soft","title":"<code>rule_of_leadlike_soft(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, tpsa=None, n_rotatable_bonds=None, n_rings=None, n_hetero_atoms=None, charge=None, **kwargs)</code>","text":"<p>Compute the Lead-Like Soft rule available in FAF-Drugs4. The rules are described at https://fafdrugs4.rpbs.univ-paris-diderot.fr/filters.html</p> <p>It computes: <pre><code>MW in [150, 400] &amp; logP &lt; in [-3, 4] &amp; HBD &lt;= 4 &amp; HBA &lt;= 7 &amp; TPSA &lt;=160 &amp; ROTBONDS &lt;= 9 &amp;\nRIGBONDS &lt;= 30 &amp; N_RINGS &lt;= 4 &amp; MAX_SIZE_RING &lt;= 18 &amp; N_CARBONS in [3, 35] &amp;  N_HETEROATOMS in [1, 15] &amp;\nHC_RATIO in [0.1, 1.1] &amp; CHARGE in [-4, 4] &amp; N_ATOM_CHARGE &lt;= 4 &amp; N_STEREO_CENTER &lt;= 2\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA. Defaults to None.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds. Defaults to None.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecules. Defaults to None.</p> <code>None</code> <code>n_hetero_atoms</code> <code>Optional[int]</code> <p>precomputed number of heteroatoms. Defaults to None.</p> <code>None</code> <code>charge</code> <code>Optional[float]</code> <p>precomputed charge. Defaults to None.</p> <code>None</code>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_oprea","title":"<code>rule_of_oprea(mol, n_hba=None, n_hbd=None, n_rotatable_bonds=None, n_rings=None, **kwargs)</code>","text":"<p>Computes Oprea's rule of drug likeness obtained by comparing drug vs non drug compounds across multiple datasets. The rules have been described in: Oprea (2000) Property distribution of drug-related chemical databases*</p> <p>It computes: <code>HBD in [0, 2] &amp; HBA in [2, 9] &amp; ROTBONDS in [2,8] and RINGS in [1, 4]</code></p> <p>Note</p> <p>Seventy percent of the `drug-like' compounds were found between the following limits: 0 \u2264 HDO \u2264 2, 2 \u2264 HAC \u2264 9, 2 \u2264 RTB \u2264 8, and 1 \u2264 RNG \u2264 4</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds in the molecule. Defaults to None.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecule. Defaults to None.</p> <code>None</code> <p>Returns     roo: True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_pfizer_3_75","title":"<code>rule_of_pfizer_3_75(mol, clogp=None, tpsa=None, **kwargs)</code>","text":"<p>Compute Pfizer Rule(3/75 Rule) for invivo toxicity. It has been described in: * Hughes, et al. (2008) Physiochemical drug properties associated with in vivo toxicological outcomes. * Price et al. (2009) Physicochemical drug properties associated with in vivo toxicological outcomes: a review</p> <p>It computes: <code>! (TPSA &lt; 75 &amp; logP &gt; 3)</code></p> <p>Note</p> <ul> <li>In vivo toleration (IVT) studies on 245 preclinical Pfizer compounds found an increased likelihood of toxic events for less polar, more lipophilic compounds.</li> <li>Compounds with low clogP / high TPSA are \u223c 2.5 times more likely not to have any toxity issue at a fixed concentration of 10 uM (total) or 1 uM (free);</li> <li>Compounds with high clogP / low TPSA are \u223c 2.5 times more likely to have a toxity finding; this represents an overall odds &gt;= 6.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>rop</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_reos","title":"<code>rule_of_reos(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, charge=None, n_rotatable_bonds=None, n_heavy_atoms=None, **kwargs)</code>","text":"<p>Compute the REOS filter. The REOS filter is a filter designed to filter out unuseful compounds from HTS screening results. The filter is described in: Waters &amp; Namchuk (2003) Designing screens: how to make your hits a hit.</p> <p>It computes: <code>MW in [200, 500] &amp; logP in [-5, 5] &amp; HBA in [0, 10] &amp; HBD in [0, 5] &amp; charge in [-2, 2] &amp; ROTBONDS in [0, 8] &amp; NHeavyAtoms in [15, 50]</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <code>charge</code> <code>Optional[int]</code> <p>precomputed formal charge. Defaults to None.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds in the molecule. Defaults to None.</p> <code>None</code> <code>n_heavy_atoms</code> <code>Optional[int]</code> <p>precomputed number of heavy atoms in the molecule. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ror</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_respiratory","title":"<code>rule_of_respiratory(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, tpsa=None, n_rotatable_bonds=None, n_rings=None, **kwargs)</code>","text":"<p>Computes drug likeness rule for Respiratory (nasal/inhalatory) molecules as described in Ritchie et al. (2009) Analysis of the Calculated Physicochemical Properties of Respiratory Drugs: Can We Design for Inhaled Drugs Yet?</p> <p>It computes: <code>MW in [240, 520]  &amp; logP in [-2, 4.7] &amp; HBONDS in [6, 12] &amp; TPSA in [51, 135] &amp; ROTBONDS in [3,8] &amp; RINGS in [1,5]</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed logP. Defaults to None.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <code>tpsa</code> <code>Optional[int]</code> <p>precomputed TPSA. Defaults to None.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds in the molecule. Defaults to None.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings. Defaults to None</p> <code>None</code> <p>Returns:</p> Name Type Description <code>roc</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_three","title":"<code>rule_of_three(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, n_rotatable_bonds=None, **kwargs)</code>","text":"<p>Compute the rule-of-3. The rule-of-three is a rule of thumb for molecular fragments (and not small molecules) published in:</p> <p>Congreve M, Carr R, Murray C, Jhoti H. (2003) <code>A \"rule of three\" for fragment-based lead discovery?</code>.</p> <p>It computes: <code>MW &lt;= 300 &amp; logP &lt;= 3 &amp; HBA &lt;= 3 &amp; HBD &lt;= 3 &amp; ROTBONDS &lt;= 3</code></p> <p>Note</p> <p>TPSA is not used in this version of the rule of three. Other version uses <code>TPSA &lt;= 60 AND logP in [-3, 3]</code> in addition</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds in the molecule. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ro3</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_three_extended","title":"<code>rule_of_three_extended(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, tpsa=None, n_rotatable_bonds=None, **kwargs)</code>","text":"<p>Compute the extended rule-of-3. This is an extenion of the rule of three that computes:</p> <p>It computes: <code>MW &lt;= 300 &amp; logP in [-3, 3]  &amp; HBA &lt;= 6 &amp; HBD &lt;= 3 &amp; ROTBONDS &lt;= 3 &amp; TPSA &lt;= 60</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA. Defaults to None.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds in the molecule. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ro3</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_two","title":"<code>rule_of_two(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, **kwargs)</code>","text":"<p>Computes rules-of-2 for reagent (building block design). It aims for prioritization of reagents that typically do not add more than 200 Da in MW or 2 units of clogP. The rule of two has been described in:</p> <p>Goldberg et al. (2015) Designing novel building blocks is an overlooked strategy to improve compound quality see: http://csmres.co.uk/cs.public.upd/article-downloads/Designing-novel-building-blocks.pdf</p> <p>Note</p> <p>Their analysis showed that molecular weight (MW) and clogP were important factors in the frequency of use of reagents. Other parameters, such as TPSA, HBA, HBD and ROTBONDS count, were less important.</p> <p>It computes <code>MW &lt;= 200 &amp; logP &lt;= 2 &amp; HBA &lt;= 4 &amp; HBD &lt;= 2</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ro2</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_veber","title":"<code>rule_of_veber(mol, tpsa=None, n_rotatable_bonds=None, **kwargs)</code>","text":"<p>Compute the Veber filter. The Veber filter is a druglike filter for orally active drugs described in:</p> <p>Veber et. al. (2002) Molecular Properties That Influence the Oral Bioavailability of Drug Candidates.</p> <p>It computes: <code>ROTBONDS &lt;= 10 &amp; TPSA &lt; 140</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA. Defaults to None.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>rov</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_xu","title":"<code>rule_of_xu(mol, n_hba=None, n_hbd=None, n_rotatable_bonds=None, n_rings=None, n_heavy_atoms=None, **kwargs)</code>","text":"<p>Computes Xu's rule of drug likeness as described in: Xu &amp; Stevenson (2000), Drug-like Index: A New Approach To Measure Drug-like Compounds and Their Diversity</p> <p>It computes <code>HBD &lt;= 5 &amp; HBA &lt;= 10 &amp; ROTBONDS in [2, 35] &amp; RINGS in [1, 7] &amp; NHeavyAtoms in [10, 50]</code>.</p> <p>Note</p> <p>A compound's Drug Likeness Index is calculated based upon the knowledge derived from known drugs selected from Comprehensive Medicinal Chemistry (CMC) database.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds in the molecule. Defaults to None.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecule. Defaults to None.</p> <code>None</code> <code>n_heavy_atoms</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecule. Defaults to None.</p> <code>None</code> <p>Returns     rox: True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_zinc","title":"<code>rule_of_zinc(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, tpsa=None, n_rotatable_bonds=None, n_rings=None, charge=None, **kwargs)</code>","text":"<p>Compute the Zinc rule for a molecule. This rule is a rule of thumb to evaluate the druglikeness of a chemical compounds, based on:</p> <p>Irwin &amp; Schoichet (2005) ZINC - A Free Database of Commercially Available Compounds for Virtual Screening.</p> <p>Also see: https://fafdrugs4.rpbs.univ-paris-diderot.fr/filters.html</p> <p>It computes: <code>MW in [60, 600] &amp; logP &lt; in [-4, 6] &amp; HBD &lt;= 6 &amp; HBA &lt;= 11 &amp; TPSA &lt;=150 &amp; ROTBONDS &lt;= 12 &amp; RIGBONDS &lt;= 50 &amp; N_RINGS &lt;= 7 &amp; MAX_SIZE_RING &lt;= 12 &amp; N_CARBONS &gt;=3 &amp; HC_RATIO &lt;= 2.0 &amp; CHARGE in [-4, 4]</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight. Defaults to None.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP. Defaults to None.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA. Defaults to None.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD. Defaults to None.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA. Defaults to None.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds. Defaults to None.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecules. Defaults to None.</p> <code>None</code> <code>charge</code> <code>Optional[float]</code> <p>precomputed charge. Defaults to None.</p> <code>None</code>"},{"location":"api/medchem.rules.html#medchem.rules.rule_filter","title":"<code>medchem.rules.rule_filter</code>","text":""},{"location":"api/medchem.rules.html#medchem.rules.rule_filter.RuleFilters","title":"<code>RuleFilters</code>","text":"<p>Build a filter based on a compound phychem properties. For a list of default rules, use <code>RuleFilters.list_available_rules()</code>. Most of these rules have been collected from the litterature including https://fafdrugs4.rpbs.univ-paris-diderot.fr/descriptors.html</p>"},{"location":"api/medchem.rules.html#medchem.rules.rule_filter.RuleFilters.__call__","title":"<code>__call__(mols, n_jobs=None, progress=False, scheduler='processes')</code>","text":"<p>Compute the rules for a list of molecules</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>List[Union[str, dm.Mol]]</code> <p>list of input molecule object.</p> required <code>n_jobs</code> <code>Optional[int]</code> <p>number of jobs to run in parallel. Defaults to None.</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress or not. Defaults to False.</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>which scheduler to use. Defaults to \"processes\".</p> <code>'processes'</code> <p>Returns:</p> Name Type Description <code>df</code> <p>Dataframe where each row is a molecule and each column is a the outcomes of applying self.rules[column].</p>"},{"location":"api/medchem.rules.html#medchem.rules.rule_filter.RuleFilters.__getitems__","title":"<code>__getitems__(ind)</code>","text":"<p>Return a specific rule</p>"},{"location":"api/medchem.rules.html#medchem.rules.rule_filter.RuleFilters.__init__","title":"<code>__init__(rule_list, rule_list_names=None, precompute_props=True)</code>","text":"<p>Build a rule filtering object</p> <p>Parameters:</p> Name Type Description Default <code>rule_list</code> <code>List[Union[str, Callable]]</code> <p>list of rules to apply. Either a callable that takes a molecule as input (with kwargs) or a string of the name of a pre-defined rule as defined in the basic_rules module</p> required <code>rule_list_names</code> <code>Optional[List[str]]</code> <p>Name of the rules passed as inputs. Defaults to None.</p> <code>None</code> <code>precompute_props</code> <code>bool</code> <p>Whether to precompute the properties for all molecules to speed up redundant calculation. Defaults to True.</p> <code>True</code>"},{"location":"api/medchem.rules.html#medchem.rules.rule_filter.RuleFilters.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of rules inside this filter</p>"},{"location":"api/medchem.rules.html#medchem.rules.rule_filter.RuleFilters.list_available_rules","title":"<code>list_available_rules(query=None)</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>List all the available rules and they properties</p>"},{"location":"api/medchem.rules.html#medchem.rules.rule_filter.RuleFilters.list_available_rules_names","title":"<code>list_available_rules_names(query=None)</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>List only the names of the available rules</p>"},{"location":"api/medchem.utils.html","title":"<code>medchem.utils</code>","text":""},{"location":"api/medchem.utils.html#medchem.utils.smarts","title":"<code>medchem.utils.smarts</code>","text":""},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils","title":"<code>SMARTSUtils</code>","text":"<p>Collections of utils to build complex SMARTS query more efficiently for non experienced user</p>"},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils.aliphatic_chain","title":"<code>aliphatic_chain(min_size=6, unbranched=False, unsaturated_bondtype=None, allow_hetero_atoms=True)</code>  <code>classmethod</code>","text":"<p>Returns a query that can match a long aliphatic chain</p> <p>Parameters:</p> Name Type Description Default <code>min_size</code> <code>int</code> <p>minimum size of the long chain</p> <code>6</code> <code>unbranched</code> <code>bool</code> <p>whether the chain should be unbranched</p> <code>False</code> <code>unsaturated_bondtype</code> <code>Optional[str]</code> <p>additional unsaturated bond type to use for the query. By default, Any bond type (~) is used. Single bonds ARE always allowed and bondtype cannot be aromatic</p> <code>None</code> <code>allow_hetero_atoms</code> <code>bool</code> <p>whether the chain can contain hetero atoms</p> <code>True</code> Example <p>to build a query for a long aliphatic chain of a least 5 atoms (e.g: 'CCC(C)CCC')</p> <p>SMARTSUtils.aliphatic_chain(min_size=5)</p> <p>Returns:</p> Name Type Description <code>smarts</code> <p>smarts pattern matching a long aliphatic chain</p>"},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils.atom_in_env","title":"<code>atom_in_env(*smarts_strs, include_atoms=False, union=False)</code>  <code>classmethod</code>","text":"<p>Returns a recursive/group smarts to find an atom that fits in the environments as defined by all the input smarts</p> <p>Parameters:</p> Name Type Description Default <code>smarts_strs</code> <p>list of input patterns defining the environment the atom must fit in. The first atom of each pattern should be the atom we want to match to, unless include_atoms is set to True, then [*:99] will be added at the start of each pattern</p> <code>()</code> <code>include_atoms</code> <code>bool</code> <p>whether to include an additional first atom that needs to be in the required environment or not</p> <code>False</code> <code>union</code> <code>bool</code> <p>whether to use the union of the environments or the intersection</p> <code>False</code> Example <p>you can use this function to construct a complex query if you are not sure about how to write the smarts for example, to find a carbon atom that is both in a ring or size 6, bonded to an ethoxy and have a Fluorine in meta</p> <p>SMARTSUtils.atom_in_env(\"#6;r6[C&amp;D1]\", \"[c]aa[F]\", union=False) # there are alternative way to write this</p> <p>Returns:</p> Name Type Description <code>smarts</code> <p>smarts pattern matching the group/environment</p>"},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils.different_fragment","title":"<code>different_fragment(*smarts_strs)</code>  <code>classmethod</code>","text":"<p>Returns a new query that match patterns that are in different fragments.</p> <p>Warning</p> <p>This feature is not supported yet by RDKit. See https://github.com/rdkit/rdkit/issues/1261</p> <p>Parameters:</p> Name Type Description Default <code>smarts_strs</code> <p>list of input patterns defining the fragments</p> <code>()</code> Example <p>matching two oxygens in a molecule will work with '[#8].[#8]', but if you want the oxygens to be in DIFFERENT fragments, then build the query with:</p> <p>SMARTSUtils.different_fragment('[#8]', '[#8]')</p> <p>Returns:</p> Name Type Description <code>smarts</code> <p>smarts pattern matching patterns that are in different fragments</p>"},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils.meta","title":"<code>meta(smarts_str1, smarts_str2, aromatic_only=False)</code>  <code>classmethod</code>","text":"<p>Returns a recursive smarts string connecting the two input smarts in <code>meta</code> of each other. Connexion points needs to be through single or double bonds</p> <p>Parameters:</p> Name Type Description Default <code>smarts_str1</code> <code>str</code> <p>first smarts pattern defining the first functional group</p> required <code>smarts_str2</code> <code>str</code> <p>second smarts pattern defining the second functional group</p> required <code>aromatic_only</code> <code>bool</code> <p>whether the ring needs to be aromatic or not</p> <code>False</code> Example <p>to build a smarts for a methyl group in meta to an oxygen (e.g: 'c1c(C)cc(O)cc1')</p> <p>SMARTSUtils.meta('[#6;!R]', '[#8]')</p> <p>Returns:</p> Name Type Description <code>smarts</code> <p>smarts pattern connecting the two input smarts in <code>meta</code> of each other</p>"},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils.ortho","title":"<code>ortho(smarts_str1, smarts_str2, aromatic_only=False)</code>  <code>classmethod</code>","text":"<p>Returns a recursive smarts string connecting the two input smarts in <code>ortho</code> of each other. Connexion points needs to be through single or double bonds</p> <p>Parameters:</p> Name Type Description Default <code>smarts_str1</code> <code>str</code> <p>first smarts pattern defining the first functional group</p> required <code>smarts_str2</code> <code>str</code> <p>second smarts pattern defining the second functional group</p> required <code>aromatic_only</code> <code>bool</code> <p>whether the ring needs to be aromatic or not</p> <code>False</code> Example <p>to build a smarts for a methyl group in ortho to an oxygen (e.g: 'C1CC(C)C(O)CC1')</p> <p>SMARTSUtils.ortho('[#6;!R]', '[#8]')</p> <p>Returns:</p> Name Type Description <code>smarts</code> <p>smarts pattern connecting the two input smarts in <code>ortho</code> of each other</p>"},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils.para","title":"<code>para(smarts_str1, smarts_str2, aromatic_only=False)</code>  <code>classmethod</code>","text":"<p>Returns a recursive smarts string connecting the two input smarts in <code>para</code> of each other. Connexion points needs to be through single or double bonds</p> <p>Parameters:</p> Name Type Description Default <code>smarts_str1</code> <code>str</code> <p>first smarts pattern defining the first functional group</p> required <code>smarts_str2</code> <code>str</code> <p>second smarts pattern defining the second functional group</p> required <code>aromatic_only</code> <code>bool</code> <p>whether the ring needs to be aromatic or not</p> <code>False</code> Example <p>to build a smarts for a methyl group in para to an oxygen (e.g: 'c1(C)ccc(O)cc1')</p> <p>SMARTSUtils.para('[#6;!R]', '[#8]')</p> <p>Returns:</p> Name Type Description <code>smarts</code> <p>smarts pattern connecting the two input smarts in <code>para</code> of each other</p>"},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils.same_fragment","title":"<code>same_fragment(*smarts_strs)</code>  <code>classmethod</code>","text":"<p>Returns a new query that match patterns that are in THE SAME fragment (component)</p> <p>Warning</p> <p>This feature is not supported yet by RDKit. See https://github.com/rdkit/rdkit/issues/1261</p> <p>Parameters:</p> Name Type Description Default <code>smarts_strs</code> <p>list of input patterns defining the fragments</p> <code>()</code> Example <p>matching two oxygens in a molecule will work with '[#8].[#8]', but if you want the oxygens to be in the SAME fragment, then build the query with:</p> <p>SMARTSUtils.same_fragment('[#8]', '[#8]')</p> <p>Returns:</p> Name Type Description <code>smarts</code> <p>smarts pattern matching patterns that are in the same component</p>"},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils.standardize_attachment","title":"<code>standardize_attachment(smiles, attach_tokens='[*:1]')</code>  <code>classmethod</code>","text":"<p>Standardize an attachment point in a smiles</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>str</code> <p>SMILES string</p> required <code>attach_tokens</code> <code>str</code> <p>Attachment point token to use as standard token</p> <code>'[*:1]'</code>"},{"location":"api/medchem.utils.html#medchem.utils.matches","title":"<code>medchem.utils.matches</code>","text":""},{"location":"api/medchem.utils.html#medchem.utils.matches.Constraints","title":"<code>Constraints</code>","text":"<p>Complex query system for matches with additional constraints</p> <p>Example</p> <p>mol1 = dm.to_mol(\"CN(C)C(=O)c1cncc(C)c1\") mol2 = dm.to_mol(\"c1ccc(cc1)-c1cccnc1\") core = dm.from_smarts(\"c1cncc([*:1])c1\") [atom.SetProp(\"query\", \"my_constraints\") for atom in core.GetAtoms() if atom.GetAtomMapNum() == 1] constraint_fns = dict(my_constraints=lambda x: dm.descriptors.n_aromatic_atoms(x) &gt; 0) constraint = Constraints(core, constraint_fns) matches = [constraint(mol1), constraint(mol2)] # False, True</p>"},{"location":"api/medchem.utils.html#medchem.utils.matches.Constraints.__call__","title":"<code>__call__(mol)</code>","text":"<p>Check if input molecule respect the constraints</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <p>input molecule</p> required"},{"location":"api/medchem.utils.html#medchem.utils.matches.Constraints.__init__","title":"<code>__init__(core, constraint_fns, prop_name='query')</code>","text":"<p>Initialize the constraint matcher</p> <p>Parameters:</p> Name Type Description Default <code>core</code> <code>dm.Mol</code> <p>the scaffold/query molecule to match against. Needs to be a molecule</p> required <code>constraint_fns</code> <code>Dict[Callable]</code> <p>a dictionary of constraints functions</p> required <code>prop_name</code> <code>str</code> <p>the property name to use in the match at each atom defined by the core for further matches against the constraints functions</p> <code>'query'</code>"},{"location":"api/medchem.utils.html#medchem.utils.matches.Constraints.get_matches","title":"<code>get_matches(mol, multiple=True)</code>","text":"<p>Get matches that respect the constraints in the molecules</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>input molecule</p> required <code>multiple</code> <code>bool</code> <p>if True, return all the matches, if False, return the first match</p> <code>True</code>"},{"location":"api/medchem.utils.html#medchem.utils.matches.Constraints.has_match","title":"<code>has_match(mol)</code>","text":"<p>Check if input molecule respect the constraints</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>input molecule</p> required"},{"location":"api/medchem.utils.html#medchem.utils.matches.Constraints.validate","title":"<code>validate(mol, constraints)</code>  <code>staticmethod</code>","text":"<p>Validate a list of constraint object against a molecule</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <p>the molecule object</p> required <code>constraints</code> <code>List[Constraints]</code> <p>list of Contraints object to validate against the molecule</p> required"},{"location":"api/medchem.utils.html#medchem.utils.loader","title":"<code>medchem.utils.loader</code>","text":""},{"location":"api/medchem.utils.html#medchem.utils.loader.get_data","title":"<code>get_data(file=None)</code>","text":"<p>Return the folder that contains the package specific data</p>"},{"location":"api/medchem.utils.html#medchem.utils.loader.get_grammar","title":"<code>get_grammar(grammar=None, as_string=False)</code>","text":"<p>Return the default lark grammar file for queries</p> <p>Parameters:</p> Name Type Description Default <code>grammar</code> <code>Optional[os.PathLike]</code> <p>The path to the grammar file. If None, the default grammar</p> <code>None</code> <code>as_string</code> <code>bool</code> <p>If True, return the grammar as a string. Defaults to False.</p> <code>False</code>"},{"location":"api/medchem.utils.html#medchem.utils.graph","title":"<code>medchem.utils.graph</code>","text":""},{"location":"api/medchem.utils.html#medchem.utils.graph.automorphism","title":"<code>automorphism(mol, standardize=True, node_attrs=DEFAULT_NODE_ATTR, edge_attrs=DEFAULT_EDGE_ATTR)</code>","text":"<p>Compute automorphism in a molecular graph</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[str, dm.Mol]</code> <p>input molecular graph</p> required <code>standardize</code> <code>bool</code> <p>whether to standardize the compound or not</p> <code>True</code> <code>node_attrs</code> <code>List[str]</code> <p>list of categorical atom attributes/properties to consider for node matching</p> <code>DEFAULT_NODE_ATTR</code> <code>edge_attrs</code> <code>List[str]</code> <p>list of categorical bond attributes/properties to consider for edge matching</p> <code>DEFAULT_EDGE_ATTR</code>"},{"location":"api/medchem.utils.html#medchem.utils.graph.score_symmetry","title":"<code>score_symmetry(mol, exclude_self_mapped_edged=False, **automorphism_kwargs)</code>","text":"<p>Provide a symmetry score for a given input molecule</p> <p>Note</p> <p>This is an heuristic and our definition of symmetry is pretty loose. We define symmetry according to any (set of) plans dividing the molecule into two very similar subgraph. We include both edge and vertex transitivity. For example the star-molecular graph (e.g neopentane) is symmetrical here, although it's not vertex-transitive. For more information see https://github.com/valence-platform/medchem/pull/41</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>inputs molecules</p> required <code>exclude_self_mapped_edged</code> <code>bool</code> <p>Whether to exclude edges that matches to themselves in automorphism.</p> <code>False</code> <code>automorphism_kwargs</code> <p>keyword for determining automorphism</p> <code>{}</code>"},{"location":"tutorials/getting-started.html","title":"Getting Started","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>import datamol as dm\nimport numpy as np\nfrom loguru import logger\n\ndata = dm.data.freesolv().sample(500)\nsmiles_list = data.smiles.values\n</pre> import datamol as dm import numpy as np from loguru import logger  data = dm.data.freesolv().sample(500) smiles_list = data.smiles.values In\u00a0[3]: Copied! <pre>from medchem.filter import lead\nfrom medchem.demerits import score, batch_score\nfrom medchem.alerts import NovartisFilters\nfrom medchem.alerts import AlertFilters\nfrom medchem.catalog import NamedCatalogs\nfrom medchem.utils import get_data\nfrom rdkit.Chem import rdfiltercatalog\n</pre> from medchem.filter import lead from medchem.demerits import score, batch_score from medchem.alerts import NovartisFilters from medchem.alerts import AlertFilters from medchem.catalog import NamedCatalogs from medchem.utils import get_data from rdkit.Chem import rdfiltercatalog In\u00a0[4]: Copied! <pre># common filters including pains, brenk, nih, zinc\npains_a = rdfiltercatalog.FilterCatalogParams.FilterCatalogs.PAINS_A\nlead.catalog_filter(smiles_list, [\"nih\", pains_a, NamedCatalogs.dundee()])\n</pre> # common filters including pains, brenk, nih, zinc pains_a = rdfiltercatalog.FilterCatalogParams.FilterCatalogs.PAINS_A lead.catalog_filter(smiles_list, [\"nih\", pains_a, NamedCatalogs.dundee()]) Out[4]: <pre>array([ True,  True,  True,  True, False, False,  True, False, False,\n        True, False,  True,  True,  True, False,  True, False, False,\n       False,  True,  True, False,  True, False, False, False,  True,\n        True,  True,  True,  True,  True, False,  True, False, False,\n       False,  True, False, False, False,  True, False, False, False,\n        True, False,  True, False,  True,  True, False,  True,  True,\n        True, False,  True, False, False, False,  True, False, False,\n        True, False,  True,  True, False, False, False, False,  True,\n        True,  True, False,  True, False,  True,  True,  True, False,\n        True,  True, False,  True,  True,  True,  True,  True, False,\n       False,  True,  True, False,  True, False, False, False,  True,\n       False, False, False, False,  True, False, False,  True,  True,\n        True,  True,  True, False,  True,  True,  True, False,  True,\n       False, False,  True,  True,  True,  True, False, False,  True,\n       False, False,  True,  True, False,  True,  True,  True,  True,\n       False, False, False,  True, False, False, False,  True, False,\n       False,  True, False, False,  True,  True,  True, False,  True,\n       False, False, False,  True,  True,  True, False,  True,  True,\n       False, False, False, False, False,  True, False, False, False,\n       False, False,  True, False,  True, False,  True, False, False,\n        True, False, False,  True, False,  True,  True,  True, False,\n        True,  True,  True,  True, False,  True,  True,  True, False,\n       False,  True,  True, False,  True, False,  True, False,  True,\n        True,  True,  True, False, False,  True, False,  True, False,\n       False,  True, False,  True, False,  True, False, False, False,\n       False,  True,  True, False, False,  True,  True, False,  True,\n        True, False,  True,  True,  True, False, False, False,  True,\n       False, False, False,  True,  True, False,  True,  True, False,\n        True,  True,  True,  True, False,  True, False,  True,  True,\n        True,  True, False,  True, False,  True, False, False,  True,\n        True,  True, False, False, False,  True,  True,  True, False,\n        True, False, False, False, False, False,  True, False,  True,\n        True, False,  True,  True,  True, False,  True,  True, False,\n       False, False,  True, False,  True, False, False, False,  True,\n        True, False,  True, False, False,  True, False, False,  True,\n        True, False, False, False,  True,  True,  True, False,  True,\n        True,  True,  True, False,  True, False, False,  True,  True,\n        True, False, False,  True, False, False, False,  True, False,\n       False, False, False,  True, False,  True,  True,  True, False,\n        True, False, False, False,  True, False,  True, False, False,\n       False, False, False, False,  True,  True,  True, False,  True,\n       False, False, False, False, False,  True,  True,  True,  True,\n       False,  True,  True,  True, False,  True, False,  True, False,\n       False, False,  True, False, False,  True,  True, False, False,\n        True,  True, False,  True,  True, False,  True, False, False,\n       False,  True,  True, False,  True,  True,  True, False, False,\n       False, False, False, False, False,  True, False, False,  True,\n        True,  True,  True,  True,  True,  True,  True, False,  True,\n        True, False, False,  True,  True,  True,  True, False, False,\n       False,  True, False,  True, False,  True,  True,  True, False,\n       False,  True,  True,  True, False,  True, False,  True, False,\n        True,  True,  True,  True,  True,  True,  True,  True, False,\n       False,  True,  True,  True, False,  True,  True, False,  True,\n       False,  True, False,  True,  True,  True, False,  True, False,\n        True,  True,  True, False, False,  True,  True, False,  True,\n        True, False,  True, False, False])</pre> In\u00a0[5]: Copied! <pre># filtering based on some commons alerts + additional lead like rules\nlead.alert_filter(smiles_list, alerts=[\"Glaxo\", \"BMS\"], rule_dict=dict(MW=[0, 100]))\n</pre> # filtering based on some commons alerts + additional lead like rules lead.alert_filter(smiles_list, alerts=[\"Glaxo\", \"BMS\"], rule_dict=dict(MW=[0, 100])) Out[5]: <pre>array([False, False, False,  True, False, False,  True, False, False,\n       False,  True,  True, False, False, False, False, False, False,\n        True,  True, False, False, False, False, False,  True,  True,\n        True, False, False,  True, False, False, False, False, False,\n       False, False, False, False,  True,  True, False, False, False,\n       False, False, False, False, False, False, False, False, False,\n       False, False,  True,  True, False, False,  True, False, False,\n       False,  True, False, False, False, False,  True, False, False,\n       False, False, False, False,  True,  True,  True, False, False,\n        True, False, False, False, False,  True, False, False, False,\n       False, False, False, False,  True,  True, False, False, False,\n       False, False, False, False,  True,  True, False, False,  True,\n       False,  True,  True, False, False, False, False, False, False,\n       False, False,  True,  True, False, False, False, False, False,\n        True, False,  True,  True, False,  True, False, False, False,\n       False, False, False, False, False, False, False,  True,  True,\n       False, False, False,  True, False, False,  True, False,  True,\n       False, False, False, False,  True,  True, False, False,  True,\n       False, False, False, False, False,  True, False, False, False,\n       False, False,  True, False,  True, False,  True, False,  True,\n       False, False, False, False, False, False, False, False, False,\n        True,  True, False, False, False, False, False, False, False,\n       False,  True,  True, False, False, False, False, False, False,\n        True, False, False,  True,  True,  True, False, False, False,\n       False, False, False, False, False,  True, False, False,  True,\n       False, False, False,  True, False, False, False, False, False,\n       False, False, False, False,  True, False, False, False, False,\n       False, False, False,  True, False, False, False,  True, False,\n       False, False, False, False, False, False, False, False, False,\n        True,  True, False, False, False,  True, False,  True,  True,\n       False,  True, False, False, False, False,  True, False, False,\n        True, False, False, False, False, False,  True, False, False,\n       False, False,  True,  True, False, False,  True, False, False,\n       False, False,  True, False, False, False, False, False, False,\n        True,  True, False, False, False,  True, False, False,  True,\n       False, False, False, False, False,  True, False, False, False,\n       False,  True, False, False, False, False,  True, False, False,\n       False,  True, False, False, False, False, False, False, False,\n       False, False, False, False, False,  True,  True,  True, False,\n       False, False, False, False, False, False,  True, False, False,\n        True, False, False, False, False,  True, False, False, False,\n       False, False, False,  True, False, False, False,  True, False,\n       False,  True, False, False, False, False, False, False,  True,\n       False,  True,  True, False,  True, False,  True, False,  True,\n       False,  True, False, False, False, False,  True, False, False,\n       False,  True,  True, False,  True,  True,  True, False, False,\n       False, False, False, False,  True, False,  True, False,  True,\n        True, False, False, False, False,  True,  True, False, False,\n        True, False, False, False,  True,  True, False, False, False,\n       False, False, False,  True, False, False, False, False, False,\n       False, False, False,  True, False, False, False,  True, False,\n       False, False,  True,  True, False, False, False,  True, False,\n       False, False, False,  True, False, False,  True, False,  True,\n       False, False, False,  True,  True, False, False,  True, False,\n       False, False,  True, False, False, False, False,  True, False,\n       False,  True, False, False, False])</pre> In\u00a0[6]: Copied! <pre># filtering based on NIBR screening deck process described in\n# \"Evolution of Novartis' small molecule screening deck design\" by Schuffenhauer, A. et al. J. Med. Chem. (2020),\n# https://dx.doi.org/10.1021/acs.jmedchem.0c01332.\nlead.screening_filter(smiles_list, return_idx=True)\n</pre> # filtering based on NIBR screening deck process described in # \"Evolution of Novartis' small molecule screening deck design\" by Schuffenhauer, A. et al. J. Med. Chem. (2020), # https://dx.doi.org/10.1021/acs.jmedchem.0c01332. lead.screening_filter(smiles_list, return_idx=True) Out[6]: <pre>array([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,\n        13,  14,  15,  17,  18,  19,  20,  21,  22,  25,  26,  27,  28,\n        29,  30,  31,  32,  33,  36,  37,  38,  40,  41,  43,  45,  47,\n        48,  49,  50,  52,  53,  54,  56,  57,  58,  59,  60,  61,  62,\n        63,  64,  65,  66,  67,  69,  71,  72,  73,  74,  75,  77,  78,\n        79,  80,  81,  82,  84,  85,  86,  87,  88,  89,  90,  91,  92,\n        93,  94,  95,  96,  97,  99, 100, 101, 102, 103, 104, 105, 106,\n       107, 108, 109, 110, 111, 112, 113, 114, 115, 117, 118, 119, 120,\n       121, 122, 123, 125, 127, 128, 129, 131, 132, 133, 134, 135, 136,\n       137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,\n       150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 163,\n       164, 165, 166, 167, 169, 170, 171, 173, 174, 175, 176, 177, 178,\n       179, 180, 181, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192,\n       194, 195, 196, 197, 198, 199, 200, 202, 203, 204, 206, 207, 208,\n       209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221,\n       222, 223, 224, 225, 226, 227, 228, 230, 231, 233, 234, 235, 236,\n       237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249,\n       250, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263,\n       264, 266, 268, 269, 270, 271, 273, 274, 275, 276, 277, 278, 279,\n       280, 281, 282, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293,\n       294, 295, 296, 297, 298, 299, 300, 303, 304, 305, 306, 307, 308,\n       309, 310, 311, 313, 314, 315, 317, 318, 319, 320, 321, 322, 323,\n       324, 325, 326, 328, 329, 331, 332, 333, 334, 336, 337, 338, 339,\n       340, 341, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 355,\n       357, 358, 359, 360, 364, 365, 366, 367, 368, 369, 370, 371, 372,\n       373, 374, 375, 376, 377, 379, 380, 381, 382, 383, 384, 385, 387,\n       388, 389, 391, 392, 393, 394, 395, 396, 397, 399, 400, 402, 403,\n       404, 406, 407, 408, 409, 410, 411, 414, 415, 416, 417, 418, 419,\n       420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432,\n       433, 434, 435, 436, 437, 438, 439, 440, 442, 443, 444, 445, 446,\n       447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459,\n       460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472,\n       473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485,\n       486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 499])</pre> In\u00a0[7]: Copied! <pre># Filter based on the demerit scoring of Eli Lilly\ntest_config = {\n    \"min_atoms\": 10, # default is 1\n    \"soft_max_atoms\": 30, # default is 30\n    \"hard_max_atoms\": 50, # default is 30\n    \"nodemerit\": False, # default is False\n    \"dthresh\": 160, # default is None with no threshold\n}\nlead.lilly_demerit_filter(smiles_list, max_demerits=160, return_idx=True, **test_config)\n</pre> # Filter based on the demerit scoring of Eli Lilly test_config = {     \"min_atoms\": 10, # default is 1     \"soft_max_atoms\": 30, # default is 30     \"hard_max_atoms\": 50, # default is 30     \"nodemerit\": False, # default is False     \"dthresh\": 160, # default is None with no threshold } lead.lilly_demerit_filter(smiles_list, max_demerits=160, return_idx=True, **test_config) Out[7]: <pre>array([  0,   4,  37,  61,  62,  72,  73,  84,  89,  98, 106, 113, 132,\n       140, 148, 178, 180, 187, 192, 203, 209, 214, 226, 240, 244, 247,\n       249, 253, 254, 259, 273, 282, 287, 293, 310, 317, 319, 324, 345,\n       374, 377, 383, 384, 385, 399, 400, 417, 419, 434, 442, 446, 448,\n       454, 455, 459, 464, 470, 473, 475, 478, 482, 485, 487, 492, 494])</pre> In\u00a0[8]: Copied! <pre>filter_obj = AlertFilters(alerts_set=[\"inpharmatica\", \"SureChEMBL\"])\nfilter_obj.list_default_available_alerts()\n</pre> filter_obj = AlertFilters(alerts_set=[\"inpharmatica\", \"SureChEMBL\"]) filter_obj.list_default_available_alerts() Out[8]: rule_set_name smarts catalog_description rule_set source 10 Glaxo 55 Glaxo Wellcome Hard filters 1 ChEMBL 5 Dundee 105 University of Dundee NTD Screening Library Fil... 2 ChEMBL 2 BMS 180 Bristol-Myers Squibb HTS Deck filters 3 ChEMBL 18 PAINS 481 PAINS filters 4 ChEMBL 21 SureChEMBL 166 SureChEMBL Non-MedChem Friendly SMARTS 5 ChEMBL 16 MLSMR 116 NIH MLSMR Excluded Functionality filters (MLSMR) 6 ChEMBL 12 Inpharmatica 91 Unwanted fragments derived by Inpharmatica Ltd. 7 ChEMBL 14 LINT 57 Pfizer lint filters (lint) 8 ChEMBL 0 Alarm-NMR 75 Reactive False Positives in Biochemical Screen... 9 Litterature 1 AlphaScreen-Hitters 6 Structural filters for compounds that may be a... 10 Litterature 8 GST-Hitters 34 Structural filters for compounds may prevent G... 11 Litterature 11 HIS-Hitters 19 Structural filters for compounds prevents the ... 12 Litterature 15 LuciferaseInhibitor 3 Structural filters for compounds that may inhi... 13 Litterature 4 DNABinder 78 Structural filters for compounds that may bind... 14 Litterature 3 Chelator 55 Structural filters for compounds that may inhi... 15 Litterature 7 Frequent-Hitter 15 Structural filters for compounds that are freq... 16 Litterature 6 Electrophilic 119 Structural filters for compounds that could ta... 17 Litterature 9 Genotoxic-Carcinogenicity 117 Structural filters for compounds that may caus... 18 Litterature 13 LD50-Oral 20 Structural filters for compounds that may caus... 19 Litterature 17 Non-Genotoxic-Carcinogenicity 22 Structural filters for compounds that may caus... 20 Litterature 19 Reactive-Unstable-Toxic 335 General very reactive/unstable or Toxic compounds 21 Litterature 20 Skin 155 Skin Sensitization filters (irritables) 22 Litterature 22 Toxicophore 154 General Toxicophores 23 Litterature In\u00a0[9]: Copied! <pre>out = filter_obj(smiles_list)\nout\n</pre> out = filter_obj(smiles_list) out Out[9]: _smiles status reasons MW LogP HBD HBA TPSA 0 c1ccc(Cn2ccnc2)cc1 Ok None 158.204 1.93140 0 2 17.82 1 NC(=O)c1ccccc1 Ok None 121.139 0.78550 1 1 43.09 2 c1cc2c3c(cccc3c1)CC2 Ok None 154.212 2.93840 0 0 0.00 3 Cc1cnccn1 Ok None 94.117 0.78502 0 2 25.78 4 CN(C)C(=O)c1ccc([N+](=O)[O-])cc1 Ok None 194.190 1.29660 0 3 63.45 ... ... ... ... ... ... ... ... ... 495 Cc1ccc(O)c(C)c1 Ok None 122.167 2.00904 1 1 20.23 496 C/C=C/CCCC Ok None 98.189 2.75270 0 0 0.00 497 CNc1ccccc1 Ok None 107.156 1.72830 1 1 12.03 498 ClCCCl Exclude alkyl_halides; Filter1_2_halo_ether; Filter26_... 98.960 1.46400 0 0 0.00 499 CCCCOC(C)=O Ok None 116.160 1.34960 0 2 26.30 <p>500 rows \u00d7 8 columns</p> In\u00a0[10]: Copied! <pre>filter_obj = NovartisFilters()\nout = filter_obj(smiles_list)\nout\n</pre> filter_obj = NovartisFilters() out = filter_obj(smiles_list) out Out[10]: _smiles status reasons severity covalent special_mol 0 c1ccc(Cn2ccnc2)cc1 Ok None 0 NaN NaN 1 NC(=O)c1ccccc1 Ok None 0 NaN NaN 2 c1cc2c3c(cccc3c1)CC2 Ok None 0 NaN NaN 3 Cc1cnccn1 Ok None 0 NaN NaN 4 CN(C)C(=O)c1ccc([N+](=O)[O-])cc1 Annotations nitro_count_1_min(1) 0 0.0 0.0 ... ... ... ... ... ... ... 495 Cc1ccc(O)c(C)c1 Ok None 0 NaN NaN 496 C/C=C/CCCC Ok None 0 NaN NaN 497 CNc1ccccc1 Ok None 0 NaN NaN 498 ClCCCl Exclude halo_ether_min(1); halogen_alkyl_min(1); halog... 10 2.0 0.0 499 CCCCOC(C)=O Ok None 0 NaN NaN <p>500 rows \u00d7 6 columns</p> In\u00a0[11]: Copied! <pre>out = score(smiles_list, **test_config)\nout\n</pre> out = score(smiles_list, **test_config) out Out[11]: _smiles ID reasons step rejected demerit_score status 0 C1=CC=C(C=C1)CN1C=CN=C1 0 NaN 4 False 0.0 Ok 1 C1=CC=C(C=C1)C(=O)N 1 not_enough_atoms 1 True NaN Exclude 2 C1=CC2=CC=CC3=C2C(=C1)CC3 2 no_interesting_atoms 1 True NaN Exclude 3 CC1=CN=CC=N1 3 not_enough_atoms 1 True NaN Exclude 4 CN(C)C(=O)C1=CC=C(C=C1)N(=O)=O 4 nitro:D60 4 False 60.0 Flag ... ... ... ... ... ... ... ... 495 CC1=CC=C(O)C(=C1)C 495 not_enough_atoms 1 True NaN Exclude 496 CCCC/C=C/C 496 not_enough_atoms 1 True NaN Exclude 497 CNC1=CC=CC=C1 497 not_enough_atoms 1 True NaN Exclude 498 C(Cl)CCl 498 not_enough_atoms 1 True NaN Exclude 499 CCCCOC(=O)C 499 not_enough_atoms 1 True NaN Exclude <p>500 rows \u00d7 7 columns</p> In\u00a0[12]: Copied! <pre># Although the demirits.score is already quite fast, you can also call the parallelized version of it using the `batch_score` function\n</pre> # Although the demirits.score is already quite fast, you can also call the parallelized version of it using the `batch_score` function In\u00a0[13]: Copied! <pre>out2 = batch_score(smiles_list, n_jobs=2,  batch_size=100,  progress=True, **test_config)\nout2\n</pre> out2 = batch_score(smiles_list, n_jobs=2,  batch_size=100,  progress=True, **test_config) out2 <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 5/5 [00:00&lt;00:00,  8.17it/s]\n</pre> Out[13]: _smiles ID reasons step rejected demerit_score status 0 C1=CC=C(C=C1)CN1C=CN=C1 0 NaN 4 False 0.0 Ok 1 C1=CC=C(C=C1)C(=O)N 1 not_enough_atoms 1 True NaN Exclude 2 C1=CC2=CC=CC3=C2C(=C1)CC3 2 no_interesting_atoms 1 True NaN Exclude 3 CC1=CN=CC=N1 3 not_enough_atoms 1 True NaN Exclude 4 CN(C)C(=O)C1=CC=C(C=C1)N(=O)=O 4 nitro:D60 4 False 60.0 Flag ... ... ... ... ... ... ... ... 495 CC1=CC=C(O)C(=C1)C 495 not_enough_atoms 1 True NaN Exclude 496 CCCC/C=C/C 496 not_enough_atoms 1 True NaN Exclude 497 CNC1=CC=CC=C1 497 not_enough_atoms 1 True NaN Exclude 498 C(Cl)CCl 498 not_enough_atoms 1 True NaN Exclude 499 CCCCOC(=O)C 499 not_enough_atoms 1 True NaN Exclude <p>500 rows \u00d7 7 columns</p> In\u00a0[14]: Copied! <pre>from medchem.groups import ChemicalGroup\nc_group = ChemicalGroup(groups=\"rings_in_drugs\")\n</pre> from medchem.groups import ChemicalGroup c_group = ChemicalGroup(groups=\"rings_in_drugs\") In\u00a0[15]: Copied! <pre>mol = dm.to_mol(\"CCS(=O)(=O)N1CC(C1)(CC#N)N2C=C(C=N2)C3=C4C=CNC4=NC=N3\")\nc_group.get_matches(mol, use_smiles=True)\n</pre> mol = dm.to_mol(\"CCS(=O)(=O)N1CC(C1)(CC#N)N2C=C(C=N2)C3=C4C=CNC4=NC=N3\") c_group.get_matches(mol, use_smiles=True)  Out[15]: name smiles smarts group matches 204 diazine C1=NC=CC=N1 [#6]1:[#7]:[#6]:[#6]:[#6]:[#7]:1 rings_in_drugs ((24, 23, 22, 18, 17, 25),) 234 1H-pyrazole N1=CC=CN1 [#7]1:[#6]:[#6]:[#6]:[#7H]:1 rings_in_drugs ((12, 13, 14, 15, 16),) 257 1H-pyrrole C1=CC=CN1 [#6]1:[#6]:[#6]:[#6]:[#7H]:1 rings_in_drugs ((20, 19, 18, 22, 21),) <p>You can also load a custom library of queries. You custom df needs to provide the following columns: <code>'smiles'/'smarts'</code>, <code>'name'</code> and <code>\"group\"</code> and optionally  <code>'hierarchy'</code></p> In\u00a0[16]: Copied! <pre>c_group = ChemicalGroup(groups_db=get_data(\"smarts_bank.csv\"))\nc_group.get_matches(mol, use_smiles=False)\n</pre> c_group = ChemicalGroup(groups_db=get_data(\"smarts_bank.csv\")) c_group.get_matches(mol, use_smiles=False) Out[16]: name smiles smarts group matches 0 HBA [!$([#6,F,Cl,Br,I,o,s,nX3,#7v5,#15v5,#16v4,#16... custom_queries ((3,), (4,), (5,), (11,), (16,), (23,), (25,)) 2 HBD [!$([#6,H0,-,-2,-3])] custom_queries ((21,),) 3 HBD [!H0;#7,#8,#9] custom_queries ((21,),) 12 Hydrogen [*!H0,#1] custom_queries ((0,), (1,), (6,), (8,), (9,), (13,), (15,), (... 13 Hydrogen [#6!H0,#1] custom_queries ((0,), (1,), (6,), (8,), (9,), (13,), (15,), (... 14 Hydrogen [H,#1] custom_queries ((13,), (15,), (19,), (20,), (21,), (24,)) 16 Acyclic Bonds *!@* custom_queries ((0, 1), (1, 2), (2, 3), (2, 4), (2, 5), (7, 9... 18 Rotable Bond [!$(*#*)&amp;!D1]-!@[!$(*#*)&amp;!D1] custom_queries ((1, 2), (2, 5), (7, 9), (7, 12), (14, 17)) 20 SP3 Nitrogen [$([NX4+]),$([NX3]);!$(*=*)&amp;!$(*:*)] custom_queries ((5,),) 21 SP2 Nitrogen [$([nX3](:*):*),$([nX2](:*):*),$([#7X2]=*),$([... custom_queries ((12,), (16,), (21,), (23,), (25,)) 22 SP2 Carbon [$([cX3](:*):*),$([cX2+](:*):*),$([CX3]=*),$([... custom_queries ((13,), (14,), (15,), (17,), (18,), (19,), (20... 23 Aromatic SP2 Carbon [$([cX3](:*):*),$([cX2+](:*):*)] custom_queries ((13,), (14,), (15,), (17,), (18,), (19,), (20... 24 Chiral Carbon [$([#6X4@](*)(*)(*)*),$([#6X4@H](*)(*)*)] custom_queries ((7,),) <p>You can apply the basic rules independently</p> In\u00a0[17]: Copied! <pre>from medchem.rules.basic_rules import rule_of_five, rule_of_three, rule_of_leadlike_soft\n</pre> from medchem.rules.basic_rules import rule_of_five, rule_of_three, rule_of_leadlike_soft In\u00a0[18]: Copied! <pre>print(\"RO5\", rule_of_five(mol))\nprint(\"RO3\", rule_of_three(mol))\nprint(\"ROLS\", rule_of_leadlike_soft(mol))\n</pre> print(\"RO5\", rule_of_five(mol)) print(\"RO3\", rule_of_three(mol)) print(\"ROLS\", rule_of_leadlike_soft(mol)) <pre>RO5 True\nRO3 False\nROLS True\n</pre> <p>To list all available rules and what they are good for, use :</p> In\u00a0[19]: Copied! <pre>from medchem.rules import RuleFilters\n</pre> from medchem.rules import RuleFilters In\u00a0[20]: Copied! <pre>RuleFilters.list_available_rules()\n</pre> RuleFilters.list_available_rules() Out[20]: name rules description 0 rule_of_five MW &lt;= 500 &amp; logP &lt;= 5 &amp; HBD &lt;= 5 &amp; HBA &lt;= 10 leadlike;druglike;small molecule;library design 1 rule_of_five_beyond MW &lt;= 1000 &amp; logP in [-2, 10] &amp; HBD &lt;= 6 &amp; HBA... leadlike;druglike;small molecule;library design 2 rule_of_four MW &gt;= 400 &amp; logP &gt;= 4 &amp; RINGS &gt;=4 &amp; HBA &gt;= 4 PPI inhibitor;druglike 3 rule_of_three MW &lt;= 300 &amp; logP &lt;= 3 &amp; HBA &lt;= 3 &amp; HBD &lt;= 3 &amp; ... fragment;building block 4 rule_of_three_extended MW &lt;= 300 &amp; logP in [-3, 3] &amp; HBA &lt;= 6 &amp; HBD &lt;... fragment;building block 5 rule_of_two MW &lt;= 200 &amp; logP &lt;= 2 &amp; HBA &lt;= 4 &amp; HBD &lt;= 2 fragment;reagent;building block 6 rule_of_ghose MW in [160, 480] &amp; logP in [-0.4, 5.6] &amp; Natom... leadlike;druglike;small molecule;library design 7 rule_of_veber rotatable bond &lt;= 10 &amp; TPSA &lt; 140 druglike;leadlike;small molecule;oral 8 rule_of_reos MW in [200, 500] &amp; logP in [-5, 5] &amp; HBA in [0... druglike;small molecule;library design;HTS 9 rule_of_chemaxon_druglikeness MW &lt; 400 &amp; logP &lt; 5 &amp; HBA &lt;= 10 &amp; HBD &lt;= 5 &amp; r... leadlike;druglike;small molecule 10 rule_of_egan TPSA in [0, 132] &amp; logP in [-1, 6] druglike;small molecule;admet;absorption;perme... 11 rule_of_pfizer_3_75 not (TPSA &lt; 75 &amp; logP &gt; 3) druglike;toxicity;invivo;small molecule 12 rule_of_gsk_4_400 MW &lt;= 400 &amp; logP &lt;= 4 druglike;admet;small molecule 13 rule_of_oprea HBD in [0, 2] &amp; HBA in [2, 9] &amp; ROTBONDS in [2... druglike;small molecule 14 rule_of_xu HBD &lt;= 5 &amp; HBA &lt;= 10 &amp; ROTBONDS in [2, 35] &amp; R... druglike;small molecule;library design 15 rule_of_cns MW in [135, 582] &amp; logP in [-0.2, 6.1] &amp; TPSA ... druglike;CNS;BBB;small molecule 16 rule_of_respiratory MW in [240, 520]  &amp; logP in [-2, 4.7] &amp; HBONDS... druglike;respiratory;small molecule;nasal;inha... 17 rule_of_zinc MW in [60, 600] &amp; logP &lt; in [-4, 6] &amp; HBD &lt;= 6... druglike;small molecule;library design;zinc 18 rule_of_leadlike_soft MW in [150, 400] &amp; logP &lt; in [-3, 4] &amp; HBD &lt;= ... leadlike;small molecule;library design;admet 19 rule_of_druglike_soft MW in [100, 600] &amp; logP &lt; in [-3, 6] &amp; HBD &lt;= ... druglike;small molecule;library design <p>To list the available rules for small molecules only,  you can use the <code>list_available_rules(\"small molecule\")</code></p> In\u00a0[21]: Copied! <pre>RuleFilters.list_available_rules(\"small molecule\")\n</pre> RuleFilters.list_available_rules(\"small molecule\") Out[21]: name rules description 0 rule_of_five MW &lt;= 500 &amp; logP &lt;= 5 &amp; HBD &lt;= 5 &amp; HBA &lt;= 10 leadlike;druglike;small molecule;library design 1 rule_of_five_beyond MW &lt;= 1000 &amp; logP in [-2, 10] &amp; HBD &lt;= 6 &amp; HBA... leadlike;druglike;small molecule;library design 6 rule_of_ghose MW in [160, 480] &amp; logP in [-0.4, 5.6] &amp; Natom... leadlike;druglike;small molecule;library design 7 rule_of_veber rotatable bond &lt;= 10 &amp; TPSA &lt; 140 druglike;leadlike;small molecule;oral 8 rule_of_reos MW in [200, 500] &amp; logP in [-5, 5] &amp; HBA in [0... druglike;small molecule;library design;HTS 9 rule_of_chemaxon_druglikeness MW &lt; 400 &amp; logP &lt; 5 &amp; HBA &lt;= 10 &amp; HBD &lt;= 5 &amp; r... leadlike;druglike;small molecule 10 rule_of_egan TPSA in [0, 132] &amp; logP in [-1, 6] druglike;small molecule;admet;absorption;perme... 11 rule_of_pfizer_3_75 not (TPSA &lt; 75 &amp; logP &gt; 3) druglike;toxicity;invivo;small molecule 12 rule_of_gsk_4_400 MW &lt;= 400 &amp; logP &lt;= 4 druglike;admet;small molecule 13 rule_of_oprea HBD in [0, 2] &amp; HBA in [2, 9] &amp; ROTBONDS in [2... druglike;small molecule 14 rule_of_xu HBD &lt;= 5 &amp; HBA &lt;= 10 &amp; ROTBONDS in [2, 35] &amp; R... druglike;small molecule;library design 15 rule_of_cns MW in [135, 582] &amp; logP in [-0.2, 6.1] &amp; TPSA ... druglike;CNS;BBB;small molecule 16 rule_of_respiratory MW in [240, 520]  &amp; logP in [-2, 4.7] &amp; HBONDS... druglike;respiratory;small molecule;nasal;inha... 17 rule_of_zinc MW in [60, 600] &amp; logP &lt; in [-4, 6] &amp; HBD &lt;= 6... druglike;small molecule;library design;zinc 18 rule_of_leadlike_soft MW in [150, 400] &amp; logP &lt; in [-3, 4] &amp; HBD &lt;= ... leadlike;small molecule;library design;admet 19 rule_of_druglike_soft MW in [100, 600] &amp; logP &lt; in [-3, 6] &amp; HBD &lt;= ... druglike;small molecule;library design <p>You can also apply the rule filter to a batch of molecules.</p> In\u00a0[22]: Copied! <pre>rule_obj = RuleFilters(rule_list=[\"rule_of_five\", \"rule_of_oprea\", \"rule_of_cns\", \"rule_of_leadlike_soft\"], rule_list_names=[\"rule_of_five\", \"rule_of_oprea\", \"rule_of_cns\", \"rule_of_leadlike_soft\"], precompute_props=True)\n</pre> rule_obj = RuleFilters(rule_list=[\"rule_of_five\", \"rule_of_oprea\", \"rule_of_cns\", \"rule_of_leadlike_soft\"], rule_list_names=[\"rule_of_five\", \"rule_of_oprea\", \"rule_of_cns\", \"rule_of_leadlike_soft\"], precompute_props=True) In\u00a0[23]: Copied! <pre>out = rule_obj(smiles_list, n_jobs=-1, progress=True)\n# you need to reset the columns because the input rule list can be columns\nout\n</pre> out = rule_obj(smiles_list, n_jobs=-1, progress=True) # you need to reset the columns because the input rule list can be columns out <pre>Props: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:00&lt;00:00, 5903.89it/s]     \nProps: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:00&lt;00:00, 7238.20it/s]\nProps: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:00&lt;00:00, 8098.33it/s]\nProps: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:00&lt;00:00, 1102.02it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 4/4 [00:00&lt;00:00,  5.86it/s]\n</pre> Out[23]: rule_of_five rule_of_oprea rule_of_cns rule_of_leadlike_soft 0 True True True True 1 True False False False 2 True False False False 3 True False False False 4 True True True True ... ... ... ... ... 495 True False False False 496 True False False False 497 True False False False 498 True False False False 499 True False False False <p>500 rows \u00d7 4 columns</p> In\u00a0[24]: Copied! <pre>from medchem import catalog\nprint(catalog.list_named_catalogs())\n</pre> from medchem import catalog print(catalog.list_named_catalogs()) <pre>['tox', 'pains', 'pains_a', 'pains_b', 'pains_c', 'nih', 'zinc', 'brenk', 'dundee', 'bms', 'glaxo', 'schembl', 'mlsmr', 'inpharmatica', 'lint', 'alarm_nmr', 'alphascreen', 'gst_hitters', 'his_hitters', 'luciferase', 'dnabinder', 'chelator', 'hitters', 'electrophilic', 'carcinogen', 'ld50_oral', 'reactive_unstable_toxic', 'skin', 'toxicophore', 'nibr', 'bredt', 'unstable_graph']\n</pre> In\u00a0[25]: Copied! <pre>from medchem.catalog import from_smarts\nimport pandas as pd\n</pre> from medchem.catalog import from_smarts import pandas as pd In\u00a0[26]: Copied! <pre>smarts_bank = pd.read_csv(get_data(\"smarts_bank.csv\"))\n</pre> smarts_bank = pd.read_csv(get_data(\"smarts_bank.csv\")) In\u00a0[27]: Copied! <pre>custom_catalog = from_smarts(smarts_bank.smarts.values, smarts_bank.name.values, entry_as_inds=False)\n</pre> custom_catalog = from_smarts(smarts_bank.smarts.values, smarts_bank.name.values, entry_as_inds=False) In\u00a0[28]: Copied! <pre>mol = \"CCS(=O)(=O)N1CC(C1)N2C=C(C=N2)C3=C4C=CNC4=NC=N3\"\nmol = dm.to_mol(mol)\nmol\n</pre> mol = \"CCS(=O)(=O)N1CC(C1)N2C=C(C=N2)C3=C4C=CNC4=NC=N3\" mol = dm.to_mol(mol) mol Out[28]: In\u00a0[29]: Copied! <pre>matches = custom_catalog.GetMatches(mol)\n[m.GetDescription() for m in matches]\n</pre> matches = custom_catalog.GetMatches(mol) [m.GetDescription() for m in matches] Out[29]: <pre>['HBA',\n 'HBD',\n 'HBD',\n 'Hydrogen',\n 'Hydrogen',\n 'Hydrogen',\n 'Acyclic Bonds',\n 'Rotable Bond',\n 'SP3 Nitrogen',\n 'SP2 Nitrogen',\n 'SP2 Carbon',\n 'Aromatic SP2 Carbon',\n 'Chiral Carbon']</pre> In\u00a0[30]: Copied! <pre>from medchem.query import QueryFilter\n</pre> from medchem.query import QueryFilter In\u00a0[31]: Copied! <pre># note that whitespace and newlines are ignored in the query\nquery = \"\"\"\n(\n    HASPROP(\"tpsa\" &lt; 80) AND HASPROP(\"clogp\" &lt; 3) AND ! HASALERT(\"pains\")\n) \n    OR \n(\n    HASPROP(\"n_heavy_atoms\" &gt;= 10) \n    AND \n    (\n        HASGROUP(\"Alcohols\") \n        OR \n        HASSUBSTRUCTURE(\"[CX3](=[OX1])O\", True, 1)\n    )\n)\n\"\"\"\n</pre> # note that whitespace and newlines are ignored in the query query = \"\"\" (     HASPROP(\"tpsa\" &lt; 80) AND HASPROP(\"clogp\" &lt; 3) AND ! HASALERT(\"pains\") )      OR  (     HASPROP(\"n_heavy_atoms\" &gt;= 10)      AND      (         HASGROUP(\"Alcohols\")          OR          HASSUBSTRUCTURE(\"[CX3](=[OX1])O\", True, 1)     ) ) \"\"\" In\u00a0[32]: Copied! <pre>data = dm.freesolv()\nquery_filter = QueryFilter(query)\nout = query_filter(data.smiles, n_jobs=-1, progress=True)\n</pre> data = dm.freesolv() query_filter = QueryFilter(query) out = query_filter(data.smiles, n_jobs=-1, progress=True) <pre>                                                                \r</pre> In\u00a0[33]: Copied! <pre>any(out)\n</pre> any(out) Out[33]: <pre>True</pre>"},{"location":"tutorials/getting-started.html#medchem","title":"Medchem\u00b6","text":"<p>Medchem is a package for applying general filtering rules on a set of molecules to ensure they have drug-like properties.</p> <p>In this tutorial, we will apply various filtering on an example dataset to get highlight the package API</p>"},{"location":"tutorials/getting-started.html#setup","title":"Setup\u00b6","text":""},{"location":"tutorials/getting-started.html#using-the-filter-module","title":"Using the filter module\u00b6","text":"<p>The filter module provides a variety of two types of filters:</p> <ul> <li><code>generic</code>: custom filtering based on some given molecule properties such as number of atoms, presence of specific atom type, etc</li> <li><code>lead</code>: filtering based on structural motifs that are known to either be toxic, reactive, unstable or frequent false positive</li> </ul>"},{"location":"tutorials/getting-started.html#advanced-options","title":"Advanced options\u00b6","text":"<p>The advanced options allow a better control over the filtering process. They also provide more information on the issues with the molecules.</p>"},{"location":"tutorials/getting-started.html#alertfilters","title":"AlertFilters\u00b6","text":"<p>These are the underlying filters called by <code>lead.alert_filter</code>. In the output, the compound status is indicated as either <code>\"Exclude\"</code> or <code>\"Ok\"</code>.</p>"},{"location":"tutorials/getting-started.html#novartisfilter","title":"NovartisFilter\u00b6","text":"<p>These are the underlying filters called by <code>lead.screening_filter</code>.</p> <p>Here is an explanation of the output:</p> <ul> <li>status: one of <code>[\"Exclude\", \"Flag\", \"Annotations\", \"Ok\"]</code> (ordered by quality). Generally, you can keep anything without the \"Exclude\" label, as long as you also apply a maximum severity score for compounds that collects too many flags.</li> <li>covalent: number of potentially covalent motifs contained in the compound</li> <li>severity: how severe are the issues with the molecules:     - <code>0</code>: compound has no flags, might have annotations;     - <code>1-9</code>:  number of flags the compound raises;     - <code>&gt;= 10</code>:  default exclusion criterion used in the paper</li> <li>special_mol: whether the compound/parts of the compound belongs to a special class of molecules (e.g peptides, glycosides, fatty acid). In that case, you should review the rejection reasons.</li> </ul>"},{"location":"tutorials/getting-started.html#demerits-scoring","title":"Demerits scoring\u00b6","text":"<p>Demerit scoring uses the Eli Lilly filter rules. Those are complex rules, that can be customized in any way you wish.</p> <p>The following \"information\" will be computed and added as columns to a DataFrame for each run:</p> <ul> <li>status: this was added for compatibility and has values <code>\"Exclude\"</code>, <code>\"Flag\"</code> or <code>\"Ok\"</code>.</li> <li>rejected : whether the molecule pass the filter or was rejected</li> <li>reasons: the reasons why the molecule was rejected if available</li> <li>demerit_score a demerit score for molecules. The lower the better. A cutoff is used to reject molecule with too many demerits, which you can refilter again after.</li> <li>step: step of the pipeline where molecule was filtered out, if available</li> </ul>"},{"location":"tutorials/getting-started.html#functional-group-filters","title":"Functional group filters\u00b6","text":"<p>It is also possible to initialize a list of functional group to use for molecules matching</p>"},{"location":"tutorials/getting-started.html#physchem-rule-application","title":"PhysChem Rule application\u00b6","text":"<p>You can also apply a set of physchem rules to a list of compounds</p>"},{"location":"tutorials/getting-started.html#available-catalogs","title":"Available Catalogs\u00b6","text":"<p>For a list of all available named catalogs, you can use <code>catalog.list_named_catalogs</code></p>"},{"location":"tutorials/getting-started.html#build-custom-catalogs","title":"Build custom catalogs\u00b6","text":"<p>You can build a custom catalog based on smarts you have defined. For example, using an internal smarts bank.</p>"},{"location":"tutorials/getting-started.html#query-system","title":"Query system\u00b6","text":"<p>Medchem provides a query system that can be used for filtering molecules based on a constructed query made of statement compliant with the provided grammar.</p> <p>Detailed information about the query system can be seen in the documentation</p>"}]}