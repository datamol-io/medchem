{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Medchem","text":"<p>Medchem - Molecular filtering for drug discovery.</p> <p>Medchem is a Python library that proposes multiple molecular medchem filters to a wide range of use cases relevant in a drug discovery context.</p>"},{"location":"index.html#installation","title":"Installation","text":"<pre><code>micromamba install -c conda-forge medchem\n</code></pre>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<p>The best way to get started is by going through the tutorials.</p>"},{"location":"index.html#usage-notice","title":"Usage Notice","text":"<p>While medchem filters, alerts and rules are powerfull ways to triage a list of drug-like compounds, it's important to always keep in mind to never apply those filters blindly. It's impossible for such filters to take into account the full diversity of the drug-like chemical space and by applying them blindly you might discard interesting compounds or let pass toxic or unwanted compounds.</p> <p>Don't blindly apply Medchem filters; you may miss gems or allow toxins.</p>"},{"location":"index.html#acknowledgement","title":"Acknowledgement","text":"<p>Medchem proposes a large list of mechem filters, alerts and rules. All of those has been built over the years by the scientific community and we would like to thanks everyone who has contributed to those collections and filtering methods.</p>"},{"location":"index.html#eli-lilly-medchem-rules","title":"Eli Lilly Medchem Rules","text":"<p>Originally proposed in \"Rules for Identifying Potentially Reactive or Promiscuous Compounds\" in 2012 by Robert F. Bruns and Ian A. Watson. Medchem is re-using the implementation from https://github.com/IanAWatson/Lilly-Medchem-Rules.</p> <p>The Medchem implementation can be used from <code>medchem.structural.lilly_demerits</code>.</p>"},{"location":"index.html#nibr-filters","title":"NIBR Filters","text":"<p>Rules used by Novartis to build their new screening deck. First proposed in \"Evolution of Novartis' small molecule screening deck design\" by Schuffenhauer, A. et al. J. Med. Chem. (2020).</p> <p>The Medchem implementation ca be found at <code>medchem.structural.NIBRFilters()</code>.</p>"},{"location":"index.html#structural-alerts-filters","title":"Structural Alerts Filters","text":"<p>These are alerts rules from the ChEMBL database curation scheme and public litterature on promiscuous compounds on commons assays. We thanks Patrick Walters for putting together this list of alerts.</p> <p>The original implementation by Patrick Walters can be found at https://github.com/PatWalters/rd_filters with its companion blog post.</p> <p>The Medchem implementation can be found at <code>medchem.structural.CommonAlertsFilters()</code>.</p>"},{"location":"index.html#rdkit-catalogs","title":"RDKit Catalogs","text":"<p>RDKit contains also contains a large list of filtering catalogs on which Medchem relies for the filtering logic.</p> <p>Those catalogs can be found at <code>medchem.catalogs.NamedCatalogs</code>.</p>"},{"location":"cli.html","title":"Medchem CLI","text":"<p>Medchem proposes CLI commands in order to filter directly from file paths. CSV, JSON, Excel, Parquet and SDF are supported.</p> <p>Available commands can be found with:</p> <pre><code>medchem --help\n</code></pre> <p>To know more about one specific command:</p> <pre><code>medchem common-alerts --help\n</code></pre>"},{"location":"api/medchem.catalogs.html","title":"<code>medchem.catalogs</code>","text":""},{"location":"api/medchem.catalogs.html#medchem.catalogs.list_named_catalogs","title":"<code>medchem.catalogs.list_named_catalogs()</code>","text":"<p>List all available named catalogs. This list will ignore all chemical groups For a list of chemical group to be queried using NamedCatalog.chemical_groups, use <code>medchem.group.list_default_chemical_groups</code></p>"},{"location":"api/medchem.catalogs.html#medchem.catalogs.merge_catalogs","title":"<code>medchem.catalogs.merge_catalogs(*catalogs)</code>","text":"<p>Merge several catalogs into a single one</p> <p>Returns:</p> Name Type Description <code>catalog</code> <code>FilterCatalog</code> <p>merged catalog</p>"},{"location":"api/medchem.catalogs.html#medchem.catalogs.catalog_from_smarts","title":"<code>medchem.catalogs.catalog_from_smarts(smarts, labels=None, mincounts=None, maxcounts=None, entry_as_inds=False)</code>","text":"<p>Load catalog from a list of smarts</p> <p>Parameters:</p> Name Type Description Default <code>smarts</code> <code>Union[Sequence[str], np.ndarray, pd.Series]</code> <p>list of input smarts to add to the catalog</p> required <code>labels</code> <code>Optional[Union[Sequence[str], np.ndarray, pd.Series]]</code> <p>list of label for each smarts</p> <code>None</code> <code>mincounts</code> <code>Optional[Union[Sequence[int], np.ndarray, pd.Series]]</code> <p>minimum count before a match is recognized</p> <code>None</code> <code>maxcounts</code> <code>Optional[Union[Sequence[int], np.ndarray, pd.Series]]</code> <p>maximum count for a match to be valid</p> <code>None</code> <code>entry_as_inds</code> <code>bool</code> <p>whether to use index for entry id or the label</p> <code>False</code> <p>Returns:</p> Name Type Description <code>catalog</code> <code>FilterCatalog</code> <p>merged catalogs</p>"},{"location":"api/medchem.catalogs.html#medchem.catalogs.NamedCatalogs","title":"<code>medchem.catalogs.NamedCatalogs</code>","text":"<p>Holder for substructure matching catalogs</p>"},{"location":"api/medchem.catalogs.html#medchem.catalogs._catalogs.NamedCatalogs.alerts","title":"<code>alerts(subset=None)</code>  <code>staticmethod</code>","text":"<p>Alerts filter catalogs commonly used in molecule filtering</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>Optional[Union[List[str], str]]</code> <p>subset of providers to consider</p> <code>None</code> <p>Returns:</p> Name Type Description <code>catalog</code> <code>FilterCatalog</code> <p>filter catalog</p>"},{"location":"api/medchem.catalogs.html#medchem.catalogs._catalogs.NamedCatalogs.bredt","title":"<code>bredt()</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Bredt fitler rules Also see example of usage by surge's https://github.com/StructureGenerator/SURGE/blob/main/doc/surge1_0.pdf</p>"},{"location":"api/medchem.catalogs.html#medchem.catalogs._catalogs.NamedCatalogs.chemical_groups","title":"<code>chemical_groups(filters='medicinal')</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Chemical group filter catalogs</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>Union[str, List[str]]</code> <p>list of tag to filter the catalog on.</p> <code>'medicinal'</code>"},{"location":"api/medchem.catalogs.html#medchem.catalogs._catalogs.NamedCatalogs.nibr","title":"<code>nibr()</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Catalog from NIBR</p> <p>Warning</p> <p>This includes all the compounds in the catalog, regardless of severity (FLAG, EXCLUDE, ANNOTATION) You likely don't want to use this for blind prioritization</p>"},{"location":"api/medchem.catalogs.html#medchem.catalogs._catalogs.NamedCatalogs.tox","title":"<code>tox(pains_a=True, pains_b=True, pains_c=False, brenk=True, nih=False, zinc=False)</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Common toxicity and interference catalog</p> <p>Parameters:</p> Name Type Description Default <code>pains_a</code> <code>bool</code> <p>whether to include PAINS filters from assay A</p> <code>True</code> <code>pains_b</code> <code>bool</code> <p>whether to include PAINS filters from assay B</p> <code>True</code> <code>pains_c</code> <code>bool</code> <p>whether to include PAINS filters from assay C</p> <code>False</code> <code>brenk</code> <code>bool</code> <p>whether to include BRENK filters</p> <code>True</code> <code>nih</code> <code>bool</code> <p>whether to include NIH filters</p> <code>False</code> <code>zinc</code> <code>bool</code> <p>whether to include ZINC filters</p> <code>False</code>"},{"location":"api/medchem.catalogs.html#medchem.catalogs._catalogs.NamedCatalogs.unstable_graph","title":"<code>unstable_graph(max_severity=5)</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Unstable molecular graph to filter out especially for generative models</p> <p>Parameters:</p> Name Type Description Default <code>max_severity</code> <code>int</code> <p>maximum severity to consider for graph rules to be acceptable</p> <code>5</code>"},{"location":"api/medchem.complexity.html","title":"<code>medchem.complexity</code>","text":""},{"location":"api/medchem.complexity.html#medchem.complexity.ComplexityFilter","title":"<code>medchem.complexity.ComplexityFilter</code>","text":"<p>Complexity filters.</p> <p>The threshold have been re-calculated using the original new zinc-15 and focusing only on commercially available compounds.</p>"},{"location":"api/medchem.complexity.html#medchem.complexity._filter.ComplexityFilter.__call__","title":"<code>__call__(mol)</code>","text":"<p>Check whether the input structure is too complex given this instance of the complexity filter Return False is the molecule is too complex, else True</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required"},{"location":"api/medchem.complexity.html#medchem.complexity._filter.ComplexityFilter.__init__","title":"<code>__init__(limit='99', complexity_metric='bertz', threshold_stats_file='zinc_15_available')</code>","text":"<p>Default complexity limit is set on at least 1 exceeding metric on the 999th permille level</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>str</code> <p>The complexity percentile outlier limit to be used (should be a string expressed as an integer)</p> <code>'99'</code> <code>complexity_metric</code> <code>str</code> <p>The complexity filter name to be used. Use <code>ComplexityFilter.list_default_available_filters</code> to list default filters. The following complexity metrics are supported by default * \"bertz\": bertz complexity index * \"sas\": synthetic accessibility score  (<code>zinc_15_available</code> only) * \"qed\": qed score  (<code>zinc_15_available</code> only) * \"clogp\": clogp for how greasy a molecule is compared to other in the same mw range  (<code>zinc_15_available</code> only) * \"whitlock\": whitlock complexity index * \"barone\": barone complexity index * \"smcm\": synthetic and molecular complexity * \"twc\":  total walk count complexity  (<code>zinc_15_available</code> only)</p> <code>'bertz'</code> <code>threshold_stats_file</code> <code>Optional[str]</code> <p>The path to or type the threshold file to be used. The default available threshold stats files are * \"zinc_12\" * \"zinc_15_available\"</p> <code>'zinc_15_available'</code>"},{"location":"api/medchem.complexity.html#medchem.complexity._filter.ComplexityFilter.list_default_available_filters","title":"<code>list_default_available_filters()</code>  <code>classmethod</code>","text":"<p>Return a list of unique filter names</p>"},{"location":"api/medchem.complexity.html#medchem.complexity._filter.ComplexityFilter.list_default_percentile","title":"<code>list_default_percentile(threshold_stats_file=None)</code>  <code>cached</code> <code>classmethod</code>","text":"<p>Return the default percentile list for the threshold file</p>"},{"location":"api/medchem.complexity.html#medchem.complexity._filter.ComplexityFilter.load_threshold_stats_file","title":"<code>load_threshold_stats_file(path=None)</code>  <code>classmethod</code>","text":"<p>Load threshold file to compute the percentille depending on the MW for each complexity_metric</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[str]</code> <p>path to the threshold file</p> <code>None</code>"},{"location":"api/medchem.complexity.html#medchem.complexity.WhitlockCT","title":"<code>medchem.complexity.WhitlockCT(mol, ringval=4, unsatval=2, heteroval=1, chiralval=2)</code>","text":"<p>A chemically intuitive measure for molecular complexity. This complexity measure has been described in : H. W. Whitlock, J. Org. Chem., 1998, 63, 7982-7989. Benzyls, fenyls, etc. are not treated at all.</p> <p>On zinc 15 commercially available dataset, the range of this score is [0, 172] with a median of 25</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>The input molecule.</p> required <code>ringval</code> <code>float</code> <p>The contribution of rings</p> <code>4</code> <code>unsatval</code> <code>float</code> <p>The contribution of the unsaturated bond.</p> <code>2</code> <code>heteroval</code> <code>float</code> <p>The contribution of the heteroatom.</p> <code>1</code> <code>chiralval</code> <code>float</code> <p>The contribution of the chiral center.</p> <code>2</code>"},{"location":"api/medchem.complexity.html#medchem.complexity.BaroneCT","title":"<code>medchem.complexity.BaroneCT(mol, chiral=False)</code>","text":"<p>Compute a Barone complexity measure for a molecule as described in:</p> <p>R. Barone and M. Chanon, J. Chem. Inf. Comput. Sci., 2001, 41 (2), pp 269\u2013272 Qi Huang, Lin-LiLi, Sheng-Yong Yang, J. Mol. Graph. Model. 2010, 28 (8), pp 775\u2013787</p> <p>Parameter values are hardcoded as in the articles. On zinc 15 commercially available dataset, the range of this score is [30, 4266] with a median of 538</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>The input molecule.</p> required <code>chiral</code> <code>bool</code> <p>Whether to include chirality in the calculation.</p> <code>False</code>"},{"location":"api/medchem.complexity.html#medchem.complexity.SMCM","title":"<code>medchem.complexity.SMCM(mol)</code>","text":"<p>Compute synthetic and molecular complexity as described in:</p> <p>TK Allu, TI Oprea, J. Chem. Inf. Model. 2005, 45(5), pp. 1237-1243. https://sci-hub.ee/10.1021/ci0501387</p> <p>On zinc 15 commercially available dataset, the range of this score is [1.93, 192.00] with a median of 42.23</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>the input molecule</p> required"},{"location":"api/medchem.complexity.html#medchem.complexity.TWC","title":"<code>medchem.complexity.TWC(mol, log10=True)</code>","text":"<p>Compute total walk count in a molecules as proxy for complexity. This score is described in: <code>twc = 1/2 sum(k=1..n-1,sum(i=atoms,awc(k,i)))</code> Gerta Rucker and Christoph Rucker, J. Chem. Inf. Comput. Sci. 1993, 33, 683-695</p> <p>On zinc 15 commercially available dataset, the range of this score is [1.20, 39.08] with a median of 10.65</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>the input molecule</p> required <code>log10</code> <code>bool</code> <p>whether to return the log10 of the values</p> <code>True</code>"},{"location":"api/medchem.constraints.html","title":"<code>medchem.constraints</code>","text":""},{"location":"api/medchem.constraints.html#medchem.constraints.Constraints","title":"<code>medchem.constraints.Constraints</code>","text":"<p>Complex query system for matches with additional constraints</p> <p>Example</p> <pre><code>mol1 = dm.to_mol(\"CN(C)C(=O)c1cncc(C)c1\")\nmol2 = dm.to_mol(\"c1ccc(cc1)-c1cccnc1\")\ncore = dm.from_smarts(\"c1cncc([*:1])c1\")\n[atom.SetProp(\"query\", \"my_constraints\") for atom in core.GetAtoms() if atom.GetAtomMapNum() == 1]\nconstraint_fns = dict(my_constraints=lambda x: dm.descriptors.n_aromatic_atoms(x) &gt; 0)\nconstraint = Constraints(core, constraint_fns)\nmatches = [constraint(mol1), constraint(mol2)] # False, True\n</code></pre>"},{"location":"api/medchem.constraints.html#medchem.constraints.Constraints.__call__","title":"<code>__call__(mol)</code>","text":"<p>Check if input molecule respect the constraints</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>input molecule</p> required"},{"location":"api/medchem.constraints.html#medchem.constraints.Constraints.__init__","title":"<code>__init__(core, constraint_fns, prop_name='query')</code>","text":"<p>Initialize the constraint matcher</p> <p>Parameters:</p> Name Type Description Default <code>core</code> <code>dm.Mol</code> <p>the scaffold/query molecule to match against. Needs to be a molecule</p> required <code>constraint_fns</code> <code>Dict[str, Callable]</code> <p>a dictionary of constraints functions</p> required <code>prop_name</code> <code>str</code> <p>the property name to use in the match at each atom defined by the core for further matches against the constraints functions</p> <code>'query'</code>"},{"location":"api/medchem.constraints.html#medchem.constraints.Constraints.get_matches","title":"<code>get_matches(mol, multiple=True)</code>","text":"<p>Get matches that respect the constraints in the molecules</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>input molecule</p> required <code>multiple</code> <code>bool</code> <p>if True, return all the matches, if False, return the first match</p> <code>True</code>"},{"location":"api/medchem.constraints.html#medchem.constraints.Constraints.has_match","title":"<code>has_match(mol)</code>","text":"<p>Check if input molecule respect the constraints</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>input molecule</p> required"},{"location":"api/medchem.constraints.html#medchem.constraints.Constraints.validate","title":"<code>validate(mol, constraints)</code>  <code>staticmethod</code>","text":"<p>Validate a list of constraint object against a molecule</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>the molecule object</p> required <code>constraints</code> <code>List[Constraints]</code> <p>list of Contraints object to validate against the molecule</p> required"},{"location":"api/medchem.functional.html","title":"<code>medchem.functional</code>","text":""},{"location":"api/medchem.functional.html#medchem.functional.alert_filter","title":"<code>medchem.functional.alert_filter(mols, alerts, alerts_db=None, n_jobs=1, progress=False, return_idx=False)</code>","text":"<p>Filter a dataset of molecules, based on common structural alerts and specific rules.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>List of molecules to filter</p> required <code>alerts</code> <code>List[str]</code> <p>List of alert collections to screen for. See <code>CommonAlertsFilters.list_default_available_alerts()</code></p> required <code>alerts_db</code> <code>Optional[Union[os.PathLike, str]]</code> <p>Path to the alert file name. The internal default file (alerts.csv) will be used if not provided</p> <code>None</code> <code>n_jobs</code> <code>Optional[int]</code> <p>Number of cpu to use</p> <code>1</code> <code>progress</code> <code>bool</code> <p>Whether to show progress bar</p> <code>False</code> <code>return_idx</code> <code>bool</code> <p>Whether to return the filtered index</p> <code>False</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule IS OK (not found in the alert catalog).</p>"},{"location":"api/medchem.functional.html#medchem.functional.nibr_filter","title":"<code>medchem.functional.nibr_filter(mols, n_jobs=None, max_severity=10, progress=False, return_idx=False)</code>","text":"<p>Filter a set of molecules based on novartis screening deck curation process Schuffenhauer, A. et al. Evolution of Novartis' small molecule screening deck design, J. Med. Chem. (2020) DOI. https://dx.doi.org/10.1021/acs.jmedchem.0c01332</p> <p>Note</p> <p>The severity argument corresponds to the accumulated severity for a compounds accross all pattern in the catalog.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>max_severity</code> <code>int</code> <p>maximum severity allowed. Default is &lt;10</p> <code>10</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>return_idx</code> <code>bool</code> <p>Whether to return the filtered index</p> <code>False</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule IS NOT REJECTED (i.e not found in the alert catalog).</p>"},{"location":"api/medchem.functional.html#medchem.functional.catalog_filter","title":"<code>medchem.functional.catalog_filter(mols, catalogs, return_idx=False, n_jobs=-1, progress=False, progress_leave=False, scheduler='processes', batch_size=100)</code>","text":"<p>Filter a list of compounds according to catalog of structures alerts and patterns</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>catalogs</code> <code>List[Union[str, rdfiltercatalog.FilterCatalog]]</code> <p>list of catalogs (name or FilterCatalog)</p> required <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>-1</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>progress_leave</code> <code>bool</code> <p>whether to leave the progress bar after completion</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'processes'</code> <code>batch_size</code> <code>int</code> <p>batch size for parallel processing. Note that <code>batch_size</code> should be increased if the number of used CPUs gets very large.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule is not found in the catalog.</p>"},{"location":"api/medchem.functional.html#medchem.functional.chemical_group_filter","title":"<code>medchem.functional.chemical_group_filter(mols, chemical_group, return_idx=False, n_jobs=None, progress=False, progress_leave=False, scheduler='threads')</code>","text":"<p>Filter a list of compounds according to a chemical group instance.</p> <p>Note</p> <p>This function will return the list of molecules that DO NOT match the chemical group</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>chemical_group</code> <code>ChemicalGroup</code> <p>a chemical group instance with the required functional groups to use.</p> required <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>progress_leave</code> <code>bool</code> <p>whether to leave the progress bar after completion</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'threads'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule DOES NOT MATCH the groups.</p>"},{"location":"api/medchem.functional.html#medchem.functional.rules_filter","title":"<code>medchem.functional.rules_filter(mols, rules, return_idx=False, n_jobs=None, progress=False, progress_leave=False, scheduler='processes')</code>","text":"<p>Filter a list of compounds according to a predefined set of rules</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>rules</code> <code>Union[List[Any], RuleFilters]</code> <p>list of rules to apply to the input molecules.</p> required <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'processes'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule MATCH the rules.</p>"},{"location":"api/medchem.functional.html#medchem.functional.complexity_filter","title":"<code>medchem.functional.complexity_filter(mols, complexity_metric='bertz', threshold_stats_file='zinc_15_available', limit='99', return_idx=False, n_jobs=None, progress=False, progress_leave=False, scheduler='processes')</code>","text":"<p>Filter a list of compounds according to a chemical group instance</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>complexity_metric</code> <code>str</code> <p>complexity metric to use Use <code>ComplexityFilter.list_default_available_filters</code> to list default filters. The following complexity metrics are supported by default * \"bertz\": bertz complexity index * \"sas\": synthetic accessibility score  (<code>zinc_15_available</code> only) * \"qed\": qed score  (<code>zinc_15_available</code> only) * \"clogp\": clogp for how greasy a molecule is compared to other in the same mw range  (<code>zinc_15_available</code> only) * \"whitlock\": whitlock complexity index * \"barone\": barone complexity index * \"smcm\": synthetic and molecular complexity * \"twc\":  total walk count complexity  (<code>zinc_15_available</code> only)</p> <code>'bertz'</code> <code>threshold_stats_file</code> <code>str</code> <p>complexity threshold statistic origin to use</p> <code>'zinc_15_available'</code> <code>limit</code> <code>str</code> <p>complexity outlier percentile to use</p> <code>'99'</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>progress_leave</code> <code>bool</code> <p>whether to leave the progress bar after completion</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'processes'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule MATCH the rules.</p>"},{"location":"api/medchem.functional.html#medchem.functional.bredt_filter","title":"<code>medchem.functional.bredt_filter(mols, return_idx=False, n_jobs=None, progress=False, progress_leave=False, scheduler='threads', batch_size=100)</code>","text":"<p>Filter a list of compounds according to Bredt's rules https://en.wikipedia.org/wiki/Bredt%27s_rule</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>progress_leave</code> <code>bool</code> <p>whether to leave the progress bar after completion</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'threads'</code> <code>batch_size</code> <code>int</code> <p>batch size for parallel processing. Note that <code>batch_size</code> should be increased if the number of used CPUs gets very large.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule is not toxic.</p>"},{"location":"api/medchem.functional.html#medchem.functional.molecular_graph_filter","title":"<code>medchem.functional.molecular_graph_filter(mols, max_severity=5, return_idx=False, n_jobs=None, progress=False, progress_leave=False, scheduler='threads')</code>","text":"<p>Filter a list of compounds according to unstable molecular graph filter list.</p> <p>This list was obtained from observation around The disallowed graphs are:</p> <ul> <li>K3,3 or K2,4 structure</li> <li>Cone of P4 or K4 with 3-ear</li> <li>Node in more than one ring of length 3 or 4</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>max_severity</code> <code>Optional[int]</code> <p>maximum acceptable severity (1-10). Default is &lt;5</p> <code>5</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>progress_leave</code> <code>bool</code> <p>whether to leave the progress bar after completion</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'threads'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule is not toxic.</p>"},{"location":"api/medchem.functional.html#medchem.functional.lilly_demerit_filter","title":"<code>medchem.functional.lilly_demerit_filter(mols, max_demerits=160, return_idx=False, n_jobs=None, progress=False, progress_leave=False, scheduler='threads', batch_size=5000, **kwargs)</code>","text":"<p>Run Lilly demerit filtering on current list of molecules</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules as smiles preferably</p> required <code>max_demerits</code> <code>Optional[int]</code> <p>Cutoff to reject molecules Defaults to 160.</p> <code>160</code> <code>return_idx</code> <code>bool</code> <p>whether to return a mask or a list of valid indexes</p> <code>False</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>progress_leave</code> <code>bool</code> <p>whether to leave the progress bar after completion</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to usescheduler</p> <code>'threads'</code> <code>batch_size</code> <code>int</code> <p>batch size for parallel processing.</p> <code>5000</code> <code>kwargs</code> <code>Any</code> <p>parameters specific to the <code>demerits.score</code> function</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.functional.html#medchem.functional.protecting_groups_filter","title":"<code>medchem.functional.protecting_groups_filter(mols, return_idx=False, protecting_groups=['fmoc', 'tert-butoxymethyl', 'tert-butyl carbamate', 'tert-butyloxycarbonyl'], n_jobs=None, progress=False, progress_leave=False, scheduler='threads')</code>","text":"<p>Filter a list of compounds according to match to  known protecting groups. Note that is a syntaxic sugar for calling chemical_group_filter with the protecting groups subset</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>protecting_groups</code> <code>List[str]</code> <p>type of protection group to consider if not provided, will use all (not advised)</p> <code>['fmoc', 'tert-butoxymethyl', 'tert-butyl carbamate', 'tert-butyloxycarbonyl']</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>progress_leave</code> <code>bool</code> <p>whether to leave the progress bar after completion</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'threads'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule DOES NOT MATCH the groups.</p>"},{"location":"api/medchem.functional.html#medchem.functional.macrocycle_filter","title":"<code>medchem.functional.macrocycle_filter(mols, max_cycle_size=10, return_idx=False, n_jobs=None, progress=False, scheduler='processes')</code>","text":"<p>Find molecules that do not infringe the strict maximum cycle size.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>max_cycle_size</code> <code>int</code> <p>strict maximum macrocycle size</p> <code>10</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'processes'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.functional.html#medchem.functional.atom_list_filter","title":"<code>medchem.functional.atom_list_filter(mols, unwanted_atom_list=None, wanted_atom_list=None, return_idx=False, n_jobs=None, progress=False, scheduler='processes')</code>","text":"<p>Find molecule without any atom from a set of unwanted atom symbols and with all atoms in the set of desirable atom list</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>unwanted_atom_list</code> <code>Optional[Sequence]</code> <p>list of undesirable atom symbol</p> <code>None</code> <code>wanted_atom_list</code> <code>Optional[Sequence]</code> <p>list of desirable atom symbol</p> <code>None</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'processes'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.functional.html#medchem.functional.ring_infraction_filter","title":"<code>medchem.functional.ring_infraction_filter(mols, hetcycle_min_size=4, return_idx=False, n_jobs=None, progress=False, scheduler='processes')</code>","text":"<p>Find molecules that have a ring infraction filter. Returning True means the molecule is fine</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>hetcycle_min_size</code> <code>int</code> <p>Minimum ring size before more than 1 hetero atom or any non single bond is allowed. This is a strict threshold (&gt;)</p> <code>4</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'processes'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.functional.html#medchem.functional.num_atom_filter","title":"<code>medchem.functional.num_atom_filter(mols, min_atoms=None, max_atoms=None, return_idx=False, n_jobs=None, progress=False, scheduler='processes')</code>","text":"<p>Find a molecule that match the atom number constraints Returning True means the molecule is fine</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>min_atoms</code> <code>Optional[int]</code> <p>strict minimum number of atoms (atoms &gt; min_atoms)</p> <code>None</code> <code>max_atoms</code> <code>Optional[int]</code> <p>strict maximum number of atoms (atoms &lt; max_atoms)</p> <code>None</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'processes'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.functional.html#medchem.functional.num_stereo_center_filter","title":"<code>medchem.functional.num_stereo_center_filter(mols, max_stereo_centers=4, max_undefined_stereo_centers=2, return_idx=False, n_jobs=None, progress=False, scheduler='processes')</code>","text":"<p>Find a molecule that match the number of stereo center constraints. Returning True means the molecule is fine</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>max_stereo_centers</code> <code>int</code> <p>strict maximum number of stereo centers (&lt;). Default is 4</p> <code>4</code> <code>max_undefined_stereo_centers</code> <code>int</code> <p>strict maximum number of undefined stereo centers (&lt;). Default is 2</p> <code>2</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'processes'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.functional.html#medchem.functional.halogenicity_filter","title":"<code>medchem.functional.halogenicity_filter(mols, thresh_F=6, thresh_Br=3, thresh_Cl=3, return_idx=False, n_jobs=None, progress=False, scheduler='processes')</code>","text":"<p>Find molecule that do not exceed halogen threshold. These thresholds are:</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>thresh_F</code> <code>int</code> <p>maximum number of fluorine</p> <code>6</code> <code>thresh_Br</code> <code>int</code> <p>maximum number of bromine</p> <code>3</code> <code>thresh_Cl</code> <code>int</code> <p>maximum number of chlorine</p> <code>3</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'processes'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.functional.html#medchem.functional.symmetry_filter","title":"<code>medchem.functional.symmetry_filter(mols, symmetry_threshold=0.8, return_idx=False, n_jobs=None, progress=False, scheduler='processes')</code>","text":"<p>Find molecules that are not symmetrical, given a symmetry threshold</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecules</p> required <code>symmetry_threshold</code> <code>float</code> <p>threshold to consider a molecule highly symmetrical</p> <code>0.8</code> <code>return_idx</code> <code>bool</code> <p>whether to return index or a boolean mask</p> <code>False</code> <code>n_jobs</code> <code>Optional[int]</code> <p>number of parallel job to run. Sequential by default</p> <code>None</code> <code>progress</code> <code>bool</code> <p>whether to show progress bar</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>joblib scheduler to use</p> <code>'processes'</code> <p>Returns:</p> Name Type Description <code>filtered_mask</code> <code>np.ndarray</code> <p>boolean array (or index array) where true means the molecule is ok.</p>"},{"location":"api/medchem.groups.html","title":"<code>medchem.groups</code>","text":""},{"location":"api/medchem.groups.html#medchem.groups.list_default_chemical_groups","title":"<code>medchem.groups.list_default_chemical_groups(hierarchy=False)</code>","text":"<p>List all the chemical groups available.</p> <p>Note</p> <p>chemical groups defines how a collection of patterns are organized. They do not correspond to individual pattern name.</p> <p>Parameters:</p> Name Type Description Default <code>hierarchy</code> <code>bool</code> <p>whether to return the full hierarchy or the group name only</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>List of chemical groups</p>"},{"location":"api/medchem.groups.html#medchem.groups.list_functional_group_names","title":"<code>medchem.groups.list_functional_group_names()</code>","text":"<p>List common functional group names</p> <p>Returns:</p> Type Description <code>list</code> <p>List of functional group names</p>"},{"location":"api/medchem.groups.html#medchem.groups.get_functional_group_map","title":"<code>medchem.groups.get_functional_group_map()</code>  <code>cached</code>","text":"<p>List common functional group names</p> <p>Returns:</p> Type Description <code>dict</code> <p>List of functional group names</p>"},{"location":"api/medchem.groups.html#medchem.groups.ChemicalGroup","title":"<code>medchem.groups.ChemicalGroup</code>","text":"<p>Build a library of chemical groups using a list of structures parsed from a file</p> <p>The default library of structure has been curated from https://github.com/Sulstice/global-chem and additional open source data.</p> <p>Note</p> <p>For new chemical groups, please minimally provide the 'smiles'/'smarts', 'name' and \"group\" and optional 'hierarchy' columns</p> <p>Warning</p> <p>The SMILES and SMARTS used in the default list of substructures do not result in the same matches. Unless specified otherwise, the SMILES will be used in the matching done by this class, whereas due to RDKit's limitation, the SMARTS will be used in the matching done by the generated catalog.</p>"},{"location":"api/medchem.groups.html#medchem.groups._groups.ChemicalGroup.dataframe","title":"<code>dataframe</code>  <code>property</code>","text":"<p>Get the dataframe of the chemical groups</p>"},{"location":"api/medchem.groups.html#medchem.groups._groups.ChemicalGroup.mol_smarts","title":"<code>mol_smarts</code>  <code>property</code>","text":"<p>Get the SMARTS of the chemical groups in this instance</p>"},{"location":"api/medchem.groups.html#medchem.groups._groups.ChemicalGroup.mols","title":"<code>mols</code>  <code>property</code>","text":"<p>Get the Molecule object of the SMILES for the chemical groups in this instance</p>"},{"location":"api/medchem.groups.html#medchem.groups._groups.ChemicalGroup.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the Name of the chemical groups in this instance</p>"},{"location":"api/medchem.groups.html#medchem.groups._groups.ChemicalGroup.smarts","title":"<code>smarts</code>  <code>property</code>","text":"<p>Get the SMARTS of the chemical groups in this instance</p>"},{"location":"api/medchem.groups.html#medchem.groups._groups.ChemicalGroup.smiles","title":"<code>smiles</code>  <code>property</code>","text":"<p>Get the SMILES of the chemical groups in this instance</p>"},{"location":"api/medchem.groups.html#medchem.groups._groups.ChemicalGroup.__init__","title":"<code>__init__(groups=None, n_jobs=None, groups_db=None)</code>","text":"<p>Build a chemical group library</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>Optional[Union[str, List[str]]]</code> <p>List of groups to use. Defaults to None where all functional groups are used</p> <code>None</code> <code>n_jobs</code> <code>Optional[int]</code> <p>Optional number of jobs to run in parallel for internally building the data. Defaults to None.</p> <code>None</code> <code>groups_db</code> <code>Optional[Union[os.PathLike, str]]</code> <p>Path to a file containing the dump of the chemical groups. Defaults is internal dataset</p> <code>None</code>"},{"location":"api/medchem.groups.html#medchem.groups._groups.ChemicalGroup.filter","title":"<code>filter(names, fuzzy=False)</code>","text":"<p>Filter the group to restrict to only the name in input</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>List[str]</code> <p>list of names to use for filters</p> required <code>fuzzy</code> <code>bool</code> <p>whether to use exact or fuzzy matching</p> <code>False</code>"},{"location":"api/medchem.groups.html#medchem.groups._groups.ChemicalGroup.get_catalog","title":"<code>get_catalog()</code>  <code>cached</code>","text":"<p>Build an rdkit catalog from the current chemical group data</p>"},{"location":"api/medchem.groups.html#medchem.groups._groups.ChemicalGroup.get_matches","title":"<code>get_matches(mol, use_smiles=True)</code>","text":"<p>Get all the functional groups in this instance that matches the input molecule</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>use_smiles</code> <code>bool</code> <p>whether to use the smiles representation of the catalog or the smarts</p> <code>True</code>"},{"location":"api/medchem.groups.html#medchem.groups._groups.ChemicalGroup.has_match","title":"<code>has_match(mol)</code>","text":"<p>Check whether the input molecule has any functional group in this instance</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required"},{"location":"api/medchem.groups.html#medchem.groups._groups.ChemicalGroup.list_groups","title":"<code>list_groups()</code>","text":"<p>List all the chemical groups available</p>"},{"location":"api/medchem.groups.html#medchem.groups._groups.ChemicalGroup.list_hierarchy_groups","title":"<code>list_hierarchy_groups()</code>","text":"<p>List all the hierarchy in chemical groups available. To get the full hierarchy on each path, split by the <code>.</code> character.</p>"},{"location":"api/medchem.query.html","title":"<code>medchem.query</code>","text":""},{"location":"api/medchem.query.html#medchem.query.QueryFilter","title":"<code>medchem.query.QueryFilter</code>","text":"<p>Query filtering system based on a custom query grammar</p>"},{"location":"api/medchem.query.html#medchem.query._eval.QueryFilter.__call__","title":"<code>__call__(mols, scheduler='processes', n_jobs=-1, progress=True)</code>","text":"<p>Call the internal chemical filter that has been build</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>List[Union[str, dm.Mol]]</code> <p>list of input molecules to filter</p> required <code>n_jobs</code> <code>int</code> <p>whether to run job in parallel and number of jobs to consider.</p> <code>-1</code> <code>scheduler</code> <code>str</code> <p>scheduler to use.</p> <code>'processes'</code> <code>progress</code> <code>bool</code> <p>whether to show job progress.</p> <code>True</code>"},{"location":"api/medchem.query.html#medchem.query._eval.QueryFilter.__init__","title":"<code>__init__(query, grammar=None, parser='lalr')</code>","text":"<p>Constructor for query filtering system</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>input unparsed query</p> required <code>grammar</code> <code>Optional[str]</code> <p>path to grammar language to use. Defaults to None, which will use the default grammar.</p> <code>None</code> <code>parser</code> <code>str</code> <p>which Lark language parser to use. Defaults to \"lalr\".</p> <code>'lalr'</code>"},{"location":"api/medchem.query.html#medchem.query.QueryOperator","title":"<code>medchem.query.QueryOperator</code>","text":"<p>A class to hold all the operators that can be used in queries</p>"},{"location":"api/medchem.query.html#medchem.query._eval.QueryOperator.getprop","title":"<code>getprop(mol, prop)</code>  <code>staticmethod</code>","text":"<p>Compute the molecular property if a molecule. This is an alternative to the hasprop function, that does not enforce any comparison.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>prop</code> <code>str</code> <p>molecular property to apply as filter on the molecule</p> required <p>Returns:</p> Name Type Description <code>property</code> <code>float</code> <p>computed property value</p>"},{"location":"api/medchem.query.html#medchem.query._eval.QueryOperator.hasalert","title":"<code>hasalert(mol, alert)</code>  <code>staticmethod</code>","text":"<p>Check if a molecule match a named alert catalog. The alert catalog needs to be one supported by the medchem package.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>alert</code> <code>str</code> <p>named catalog to apply as filter on the molecule</p> required <p>Returns:</p> Name Type Description <code>has_alert</code> <code>bool</code> <p>whether the molecule has a given alert</p>"},{"location":"api/medchem.query.html#medchem.query._eval.QueryOperator.hasgroup","title":"<code>hasgroup(mol, group)</code>  <code>staticmethod</code>","text":"<p>Check if a molecule has a specific functional group. Internally, this is done fetching the smarts corresponding to the group then calling <code>QueryOperator.hassubstructure</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>group</code> <code>str</code> <p>functional group to check on the molecule.</p> required <p>Returns:</p> Name Type Description <code>has_group</code> <code>bool</code> <p>whether the molecule has the given functional group</p>"},{"location":"api/medchem.query.html#medchem.query._eval.QueryOperator.hasprop","title":"<code>hasprop(mol, prop, comparator, limit)</code>  <code>staticmethod</code>","text":"<p>Check if a molecule has a molecule property within desired range</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>prop</code> <code>str</code> <p>molecular property to apply as filter on the molecule</p> required <code>comparator</code> <code>Callable</code> <p>operator function to apply to check whether the molecule property matches the expected value</p> required <code>limit</code> <code>float</code> <p>limit value for determining whether the molecule property is within desired range</p> required <p>Returns:</p> Name Type Description <code>has_property</code> <code>bool</code> <p>whether the molecule has a given property within a desired range</p>"},{"location":"api/medchem.query.html#medchem.query._eval.QueryOperator.hassubstructure","title":"<code>hassubstructure(mol, query, is_smarts=False, operator='min', limit=1)</code>  <code>staticmethod</code>","text":"<p>Check if a molecule has substructure provided by a query</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>query</code> <code>str</code> <p>input smarts query</p> required <code>is_smarts</code> <code>bool</code> <p>whether this is a smarts query or not</p> <code>False</code> <code>operator</code> <code>Optional[str]</code> <p>one of min or max to specify the min or max limit</p> <code>'min'</code> <code>limit</code> <code>int</code> <p>limit of substructures to be found</p> <code>1</code> <p>Returns:</p> Name Type Description <code>has_substructure</code> <code>bool</code> <p>whether the query is a subgraph of the molecule</p>"},{"location":"api/medchem.query.html#medchem.query._eval.QueryOperator.hassuperstructure","title":"<code>hassuperstructure(mol, query)</code>  <code>staticmethod</code>","text":"<p>Check if a molecule has a superstructure defined by a query. Note that a superstructure cannot be a query (smarts)</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>query</code> <code>str</code> <p>input smarts query</p> required <p>Returns:</p> Name Type Description <code>has_superstructure</code> <code>bool</code> <p>whether the molecule is a subgraph of the query</p>"},{"location":"api/medchem.query.html#medchem.query._eval.QueryOperator.like","title":"<code>like(mol, query, comparator, limit)</code>  <code>staticmethod</code>","text":"<p>Check if a molecule is similar or distant enough from another molecule using tanimoto ECFP distance. and is useful for letting python handles the binary comparison operators.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>query</code> <code>Union[dm.Mol, str]</code> <p>input molecule to compare with</p> required <code>comparator</code> <code>Callable[[float, float], bool]</code> <p>operator function to apply to check whether the molecule property matches the expected value. Takes computed_similarity and <code>limit</code> as arguments and returns a boolean.</p> required <code>limit</code> <code>float</code> <p>limit value for determining whether the molecule property is within desired range</p> required <p>Returns:</p> Name Type Description <code>is_similar</code> <code>bool</code> <p>whether the molecule is similar or distant enough from the query</p>"},{"location":"api/medchem.query.html#medchem.query._eval.QueryOperator.matchrule","title":"<code>matchrule(mol, rule)</code>  <code>staticmethod</code>","text":"<p>Check if a molecule match a druglikeness rule</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>rule</code> <code>str</code> <p>druglikeness rule check on the molecule.</p> required <p>Returns:</p> Name Type Description <code>match_rule</code> <code>bool</code> <p>whether the molecule match the given rule</p>"},{"location":"api/medchem.query.html#medchem.query._eval.QueryOperator.similarity","title":"<code>similarity(mol, query)</code>  <code>staticmethod</code>","text":"<p>Compute the ECFP tanimoto similarity between two molecules. This is an alternative to the like function, that does not enforce any comparison, and is useful for letting python handles the binary comparison operators.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>query</code> <code>Union[dm.Mol, str]</code> <p>input query molecule to compute similarity against</p> required <p>Returns:</p> Name Type Description <code>similarity</code> <code>float</code> <p>computed similarity value between mol and query</p>"},{"location":"api/medchem.query.html#medchem.query.EvaluableQuery","title":"<code>medchem.query.EvaluableQuery</code>","text":"<p>Parser of a query into a list of evaluable function nodes</p>"},{"location":"api/medchem.query.html#medchem.query._eval.EvaluableQuery.__call__","title":"<code>__call__(mol, exec=True)</code>","text":"<p>Evaluate a query on an input molecule</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>exec</code> <code>bool</code> <p>whether to interpret the resulting query or not</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>query string or boolean value corresponding to the query result</p>"},{"location":"api/medchem.query.html#medchem.query._eval.EvaluableQuery.__init__","title":"<code>__init__(parsed_query, verbose=False)</code>","text":"<p>Constructor for query evaluation</p> <p>Parameters:</p> Name Type Description Default <code>parsed_query</code> <code>Union[str, ParseTree]</code> <p>query that has been parsed and transformed</p> required <code>verbose</code> <code>bool</code> <p>whether to print debug information</p> <code>False</code>"},{"location":"api/medchem.query.html#medchem.query.QueryParser","title":"<code>medchem.query.QueryParser</code>","text":"<p>         Bases: <code>Transformer</code></p> <p>Query parser for the custom query language for molecule. This parses the input language, build a parseable and evaluable representation. The trick for lazy evaluation is to define custom guard with '<code>fn(*)</code>' around expression that needs to be evaluated.</p> <p>Note that you SHOULD NOT HAVE TO INTERACT WITH THIS CLASS DIRECTLY.</p> Example <pre><code>import medchem\nimport lark\nQUERY_GRAMMAR = medchem.utils.loader.get_grammar(as_string=True)\nQUERY_PARSER = Lark(QUERY_GRAMMAR, parser=\"lalr\", transformer=QueryParser())\n# see how the string needs to be \"quoted\". This builds on the json quote requirements to avoid dealing with unwanted outcomes\nexample = \"\"\"(HASPROP(\"tpsa\" &gt; 120 ) | HASSUBSTRUCTURE(\"c1ccccc1\")) AND NOT HASALERT(\"pains\") OR HASSUBSTRUCTURE(\"[OH]\", max)\"\"\"\nt = QUERY_PARSER.parse(example)\nprint(t)\n((((`fn(getprop, prop='tpsa')` &gt; 120.0) or `fn(hassubstructure, query='c1ccccc1', operator='None', limit=None, is_smarts=None)`) and not `fn(hasalert, alert='pains')`) or `fn(hassubstructure, query='[OH]', operator='max', limit=None, is_smarts=None)`)\n</code></pre>"},{"location":"api/medchem.query.html#medchem.query._parser.QueryParser.bool_expr","title":"<code>bool_expr(bool_term, *others)</code>","text":"<p>Define how boolean expressions should be parsed</p>"},{"location":"api/medchem.query.html#medchem.query._parser.QueryParser.bool_term","title":"<code>bool_term(bool_factor, *others)</code>","text":"<p>Define how boolean terms should be parsed</p>"},{"location":"api/medchem.query.html#medchem.query._parser.QueryParser.hasalert","title":"<code>hasalert(value)</code>","text":"<p>Format the hasalert node in the query</p> <p>Note</p> <p>The parser does not enforce any validity on the argument and the underlying function is supposed to handle it.</p>"},{"location":"api/medchem.query.html#medchem.query._parser.QueryParser.hasgroup","title":"<code>hasgroup(value)</code>","text":"<p>Format the hasgroup node in the query</p> <p>Note</p> <p>The parser does not enforce any validity on the argument and the underlying function is supposed to handle it.</p>"},{"location":"api/medchem.query.html#medchem.query._parser.QueryParser.hasprop","title":"<code>hasprop(value, comparator, limit)</code>","text":"<p>Format the hasprop node in the query</p> <p>Note</p> <p>The parser does not enforce any validity on the argument and the underlying function is supposed to handle it.</p>"},{"location":"api/medchem.query.html#medchem.query._parser.QueryParser.hassubstructure","title":"<code>hassubstructure(value, is_smarts, operator, limit)</code>","text":"<p>Format the substructure node in the query</p> <p>Note</p> <p>The parser does not enforce any validity on the argument and the underlying function is supposed to handle it.</p>"},{"location":"api/medchem.query.html#medchem.query._parser.QueryParser.hassuperstructure","title":"<code>hassuperstructure(value)</code>","text":"<p>Format the superstructure node in the query</p> <p>Note</p> <p>The parser does not enforce any validity on the argument and the underlying function is supposed to handle it.</p>"},{"location":"api/medchem.query.html#medchem.query._parser.QueryParser.like","title":"<code>like(value, comparator, limit)</code>","text":"<p>Format the like node in the query</p> <p>Note</p> <p>The parser does not enforce any validity on the argument and the underlying function is supposed to handle it.</p>"},{"location":"api/medchem.query.html#medchem.query._parser.QueryParser.matchrule","title":"<code>matchrule(value)</code>","text":"<p>Format the matchrule node in the query</p> <p>Note</p> <p>The parser does not enforce any validity on the argument and the underlying function is supposed to handle it.</p>"},{"location":"api/medchem.query.html#medchem.query._parser.QueryParser.not_bool_factor","title":"<code>not_bool_factor(*args)</code>","text":"<p>Define representation of a negation</p>"},{"location":"api/medchem.rules.html","title":"<code>medchem.rules</code>","text":""},{"location":"api/medchem.rules.html#medchem.rules.RuleFilters","title":"<code>medchem.rules.RuleFilters</code>","text":"<p>Build a filter based on a compound phychem properties. For a list of default rules, use <code>RuleFilters.list_available_rules()</code>. Most of these rules have been collected from the litterature including https://fafdrugs4.rpbs.univ-paris-diderot.fr/descriptors.html</p>"},{"location":"api/medchem.rules.html#medchem.rules._rule_filter.RuleFilters.__call__","title":"<code>__call__(mols, n_jobs=-1, progress=False, progress_leave=False, scheduler='auto', keep_props=False, fail_if_invalid=True)</code>","text":"<p>Compute the rules for a list of molecules</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecule object.</p> required <code>n_jobs</code> <code>Optional[int]</code> <p>number of jobs to run in parallel.</p> <code>-1</code> <code>progress</code> <code>bool</code> <p>whether to show progress or not.</p> <code>False</code> <code>progress_leave</code> <code>bool</code> <p>whether to leave the progress bar or not.</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>which scheduler to use. If \"auto\", will use \"processes\" if <code>len(mols) &gt; 500</code> else \"threads\".</p> <code>'auto'</code> <code>keep_props</code> <code>bool</code> <p>whether to keep the properties columns computed by the rules.</p> <code>False</code> <code>fail_if_invalid</code> <code>bool</code> <p>whether to fail if a rule fails or not.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>df</code> <code>pd.DataFrame</code> <p>Dataframe where each row is a molecule and each column is a the outcomes of applying self.rules[column].</p>"},{"location":"api/medchem.rules.html#medchem.rules._rule_filter.RuleFilters.__getitems__","title":"<code>__getitems__(name)</code>","text":"<p>Return a specific rule</p>"},{"location":"api/medchem.rules.html#medchem.rules._rule_filter.RuleFilters.__init__","title":"<code>__init__(rule_list, rule_list_names=None)</code>","text":"<p>Build a rule filtering object</p> <p>Parameters:</p> Name Type Description Default <code>rule_list</code> <code>List[Union[str, Callable]]</code> <p>list of rules to apply. Either a callable that takes a molecule as input (with kwargs) or a string of the name of a pre-defined rule as defined in the basic_rules module</p> required <code>rule_list_names</code> <code>Optional[List[Optional[str]]]</code> <p>Name of the rules passed as inputs. Defaults to None.</p> <code>None</code>"},{"location":"api/medchem.rules.html#medchem.rules._rule_filter.RuleFilters.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of rules inside this filter</p>"},{"location":"api/medchem.rules.html#medchem.rules._rule_filter.RuleFilters.list_available_rules","title":"<code>list_available_rules(*query)</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>List all the available rules and they properties</p>"},{"location":"api/medchem.rules.html#medchem.rules._rule_filter.RuleFilters.list_available_rules_names","title":"<code>list_available_rules_names(*query)</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>List only the names of the available rules</p>"},{"location":"api/medchem.rules.html#basic-rules","title":"Basic Rules","text":""},{"location":"api/medchem.rules.html#medchem.rules.basic_rules","title":"<code>medchem.rules.basic_rules</code>","text":""},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_chemaxon_druglikeness","title":"<code>rule_of_chemaxon_druglikeness(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, n_rotatable_bonds=None, n_rings=None, **kwargs)</code>","text":"<p>Compute the drug likeness filter according to chemaxon:</p> <p>It computes: <code>MW &lt; 400 &amp; logP &lt; 5 &amp; HBA &lt;= 10 &amp; HBD &lt;= 5 &amp; ROTBONDS &lt; 5 &amp; ring &gt; 0</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds in the molecule.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecule.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>roc</code> <code>bool</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_cns","title":"<code>rule_of_cns(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, tpsa=None, **kwargs)</code>","text":"<p>Computes drug likeness rule for CNS penetrant molecules as described in: Jeffrey &amp; Summerfield (2010) Assessment of the blood-brain barrier in CNS drug discovery.</p> <p>It computes: <code>MW in [135, 582]  &amp; logP in [-0.2, 6.1] &amp; TPSA in [3, 118] &amp; HBD &lt;= 3 &amp; HBA &lt;= 5</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed logP.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>tpsa</code> <code>Optional[int]</code> <p>precomputed TPSA.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>roc</code> <code>bool</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_druglike_soft","title":"<code>rule_of_druglike_soft(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, tpsa=None, n_rotatable_bonds=None, n_rings=None, n_hetero_atoms=None, charge=None, **kwargs)</code>","text":"<p>Compute the DrugLike Soft rule available in FAF-Drugs4. The rules are described at https://fafdrugs4.rpbs.univ-paris-diderot.fr/filters.html</p> <p>It computes: <pre><code>MW in [100, 600] &amp; logP &lt; in [-3, 6] &amp; HBD &lt;= 7 &amp; HBA &lt;= 12 &amp; TPSA &lt;=180 &amp; ROTBONDS &lt;= 11 &amp;\nRIGBONDS &lt;= 30 &amp; N_RINGS &lt;= 6 &amp; MAX_SIZE_RING &lt;= 18 &amp; N_CARBONS in [3, 35] &amp;  N_HETEROATOMS in [1, 15] &amp;\nHC_RATIO in [0.1, 1.1] &amp; CHARGE in [-4, 4] &amp; N_ATOM_CHARGE &lt;= 4\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecules.</p> <code>None</code> <code>n_hetero_atoms</code> <code>Optional[int]</code> <p>precomputed number of heteroatoms.</p> <code>None</code> <code>charge</code> <code>Optional[float]</code> <p>precomputed charge.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_egan","title":"<code>rule_of_egan(mol, clogp=None, tpsa=None, **kwargs)</code>","text":"<p>Compute passive intestinal absorption according to Egan Rules as described in: Egan, William J., Kenneth M. Merz, and John J. Baldwin (2000) Prediction of drug absorption using multivariate statistics</p> <p>It computes: <code>TPSA in [0, 132] &amp; logP in [-1, 6]</code></p> <p>Note</p> <p>The author built a multivariate statistics model of passive intestinal absorption with robust outlier detection. Outliers were identified as being actively transported. They chose PSA and AlogP98 (cLogP), based on consideration of the physical processes involved in membrane permeability and the interrelationships and redundancies between other available descriptors. Compounds, which had been assayed for Caco-2 cell permeability, demonstrated a good rate of successful predictions (74\u221292%)</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>roe</code> <code>bool</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_five","title":"<code>rule_of_five(mol, mw=None, clogp=None, n_lipinski_hbd=None, n_lipinski_hba=None, **kwargs)</code>","text":"<p>Compute the Lipinski's rule-of-5 for a molecule. Also known as Pfizer's rule of five or RO5, this rule is a rule of thumb to evaluate the druglikeness of a chemical compounds</p> <p>It computes: <code>MW &lt;= 500 &amp; logP &lt;= 5  &amp; HBD &lt;= 5 &amp; HBA &lt;= 10</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>n_lipinski_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>n_lipinski_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ro5</code> <code>bool</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_five_beyond","title":"<code>rule_of_five_beyond(mol, mw=None, clogp=None, n_hbd=None, n_hba=None, tpsa=None, n_rotatable_bonds=None, **kwargs)</code>","text":"<p>Compute the Beyond rule-of-5 rule for a molecule. This rule illustrates the potential of compounds far beyond rule of 5 space to modulate novel and difficult target classes that have large, flat, and groove-shaped binding sites and has been described in:</p> <p>Doak, Bradley C., et al. (2015) How Beyond Rule of 5 Drugs and Clinical Candidates Bind to Their Targets.</p> <p>It computes: <code>MW &lt;= 1000 &amp; logP in [-2, 10] &amp; HBD &lt;= 6 &amp; HBA &lt;= 15 &amp; TPSA &lt;=250 &amp; ROTBONDS &lt;= 20</code></p> <p>Note</p> <p>This is a very permissive rule and is likely to not be a good predictor for druglikeness as known for small molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ro5</code> <code>bool</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_four","title":"<code>rule_of_four(mol, mw=None, clogp=None, n_hba=None, n_rings=None, **kwargs)</code>","text":"<p>Compute the rule-of-4 for a molecule. The rule-of-4 define a rule of thumb for PPI inhibitors, which are typically larger and more lipophilic than inhibitors of more standard binding sites. It has been published in:</p> <p>Morelli X, Bourgeas R, Roche P. (2011) Chemical and structural lessons from recent successes in protein\u2013protein interaction inhibition. Also see: Shin et al. (2020) Current Challenges and Opportunities in Designing Protein\u2013Protein Interaction Targeted Drugs. doi:10.2147/AABC.S235542</p> <p>It computes: <code>MW &gt;= 400 &amp; logP &gt;= 4  &amp; RINGS &gt;=4 &amp; HBA &gt;= 4</code></p> <p>Warning</p> <p>Do not use this for small molecules that are not PPI inhibitors</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecules.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ro4</code> <code>bool</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_generative_design","title":"<code>rule_of_generative_design(mol, mw=None, clogp=None, n_lipinski_hba=None, n_lipinski_hbd=None, tpsa=None, n_rotatable_bonds=None, n_hetero_atoms=None, charge=None, **kwargs)</code>","text":"<p>Compute druglikeness rule of generative design.</p> <p>This set of rules are proprietary of Valence Discovery and have been curated to better filters molecules suggested by generative models for small molecules</p> <p>It computes:</p> <pre><code>MW in [200, 600] &amp; logP &lt; in [-3, 6] &amp; HBD &lt;= 7  &amp; HBA &lt;= 12 &amp; TPSA in [40, 180] &amp;\nROTBONDS &lt;= 15 &amp; RIGID BONDS &lt;= 30 &amp; N_AROMATIC_RINGS &lt;= 5 &amp; N_FUSED_AROMATIC_RINGS_TOGETHER &lt;= 2 &amp;\nMAX_SIZE_RING_SYSTEM &lt;= 18  &amp; N_CARBONS in [3, 40] &amp; N_HETEROATOMS in [1, 15] &amp; CHARGE in [-2, 2] &amp;\nN_ATOM_CHARGE &lt;= 2 &amp; N_TOTAL_ATOMS &lt; 70 &amp; N_HEAVY_METALS &lt; 1\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>n_lipinski_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>n_lipinski_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds.</p> <code>None</code> <code>n_hetero_atoms</code> <code>Optional[int]</code> <p>precomputed number of heteroatoms.</p> <code>None</code> <code>charge</code> <code>Optional[float]</code> <p>precomputed charge.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_generative_design_strict","title":"<code>rule_of_generative_design_strict(mol, mw=None, clogp=None, n_lipinski_hba=None, n_lipinski_hbd=None, tpsa=None, n_rotatable_bonds=None, n_hetero_atoms=None, charge=None, **kwargs)</code>","text":"<p>Compute druglikeness rule of generative design.</p> <p>This set of rules are proprietary of Valence Discovery and have been curated to better filters molecules suggested by generative models</p> <p>It computes:</p> <pre><code>MW in [200, 600] &amp; logP &lt; in [-3, 6] &amp; HBD &lt;= 7  &amp; HBA &lt;= 12 &amp; TPSA in [40, 180] &amp;\nROTBONDS &lt;= 15 &amp; RIGID BONDS &lt;= 30 &amp; N_AROMATIC_RINGS &lt;= 5 &amp; N_FUSED_AROMATIC_RINGS_TOGETHER &lt;= 2 &amp;\nMAX_SIZE_RING_SYSTEM &lt;= 18  &amp; N_CARBONS in [3, 40] &amp; N_HETEROATOMS in [1, 15] &amp; CHARGE in [-2, 2] &amp;\nN_ATOM_CHARGE &lt;= 2 &amp; N_TOTAL_ATOMS &lt; 70 &amp; N_HEAVY_METALS &lt; 1 &amp; N_STEREO_CENTER &lt;= 3 &amp;\nHAS_NO_SPIDER_SIDE_CHAINS &amp; FRACTION_RING_SYSTEM &gt;= 0.25\n</code></pre> <p>By default SPIDER_SIDE_CHAINS are defined as having at least 2 'chains' of  &gt;=4 consecutif atoms in side chains (not part of any ring system)</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>n_lipinski_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>n_lipinski_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds.</p> <code>None</code> <code>n_hetero_atoms</code> <code>Optional[int]</code> <p>precomputed number of heteroatoms.</p> <code>None</code> <code>charge</code> <code>Optional[float]</code> <p>precomputed charge.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_ghose","title":"<code>rule_of_ghose(mol, mw=None, clogp=None, mr=None, **kwargs)</code>","text":"<p>Compute the Ghose filter. The Ghose filter is a drug-like filter described in: Ghose, AK.; Viswanadhan, VN.; Wendoloski JJ. (1999) A knowledge-based approach in designing combinatorial or medicinal chemistry libraries for drug discovery.1. A qualitative and quantitative characterization of known drug databases.</p> <p>It computes: <code>MW in [160, 480] &amp; logP in [-0.4, 5.6] &amp; Natoms in [20, 70] &amp; refractivity in [40, 130]</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>mr</code> <code>Optional[float]</code> <p>precomputed molecule refractivity.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>rog</code> <code>bool</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_gsk_4_400","title":"<code>rule_of_gsk_4_400(mol, mw=None, clogp=None, **kwargs)</code>","text":"<p>Compute GSK Rule (4/400) for druglikeness using interpretable ADMET rule of thumb based on Gleeson, M. Paul (2008). Generation of a set of simple, interpretable ADMET rules of thumb.</p> <p>It computes: <code>MW &lt;= 400 &amp; logP &lt;= 4</code>.</p> <p>Note</p> <ul> <li>The rule are based on a set of consistent structure-property guides determined from an analysis of a number of key     ADMET assays run within GSK: solubility, permeability, bioavailability, volume of distribution, plasma protein binding,     CNS penetration, brain tissue binding, P-gp efflux, hERG inhibition, and cytochrome P450 1A2/2C9/2C19/2D6/3A4 inhibition.</li> <li>Conclusion: It is clear from the analyses reported herein that almost all ADMET parameters deteriorate with either increasing molecular weight,     logP, or both, with ionization state playing either a beneficial or detrimental affect depending on the parameter in question.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>rog</code> <code>bool</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_leadlike_soft","title":"<code>rule_of_leadlike_soft(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, tpsa=None, n_rotatable_bonds=None, n_rings=None, n_hetero_atoms=None, charge=None, **kwargs)</code>","text":"<p>Compute the Lead-Like Soft rule available in FAF-Drugs4. The rules are described at https://fafdrugs4.rpbs.univ-paris-diderot.fr/filters.html</p> <p>It computes: <pre><code>MW in [150, 400] &amp; logP &lt; in [-3, 4] &amp; HBD &lt;= 4 &amp; HBA &lt;= 7 &amp; TPSA &lt;=160 &amp; ROTBONDS &lt;= 9 &amp;\nRIGBONDS &lt;= 30 &amp; N_RINGS &lt;= 4 &amp; MAX_SIZE_RING &lt;= 18 &amp; N_CARBONS in [3, 35] &amp;  N_HETEROATOMS in [1, 15] &amp;\nHC_RATIO in [0.1, 1.1] &amp; CHARGE in [-4, 4] &amp; N_ATOM_CHARGE &lt;= 4 &amp; N_STEREO_CENTER &lt;= 2\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecules.</p> <code>None</code> <code>n_hetero_atoms</code> <code>Optional[int]</code> <p>precomputed number of heteroatoms.</p> <code>None</code> <code>charge</code> <code>Optional[float]</code> <p>precomputed charge.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_oprea","title":"<code>rule_of_oprea(mol, n_hba=None, n_hbd=None, n_rotatable_bonds=None, n_rings=None, **kwargs)</code>","text":"<p>Computes Oprea's rule of drug likeness obtained by comparing drug vs non drug compounds across multiple datasets. The rules have been described in: Oprea (2000) Property distribution of drug-related chemical databases*</p> <p>It computes: <code>HBD in [0, 2] &amp; HBA in [2, 9] &amp; ROTBONDS in [2,8] and RINGS in [1, 4]</code></p> <p>Note</p> <p>Seventy percent of the `drug-like' compounds were found between the following limits: 0 \u2264 HDO \u2264 2, 2 \u2264 HAC \u2264 9, 2 \u2264 RTB \u2264 8, and 1 \u2264 RNG \u2264 4</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds in the molecule.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecule.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns     roo: True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_pfizer_3_75","title":"<code>rule_of_pfizer_3_75(mol, clogp=None, tpsa=None, **kwargs)</code>","text":"<p>Compute Pfizer Rule(3/75 Rule) for invivo toxicity. It has been described in: * Hughes, et al. (2008) Physiochemical drug properties associated with in vivo toxicological outcomes. * Price et al. (2009) Physicochemical drug properties associated with in vivo toxicological outcomes: a review</p> <p>It computes: <code>! (TPSA &lt; 75 &amp; logP &gt; 3)</code></p> <p>Note</p> <ul> <li>In vivo toleration (IVT) studies on 245 preclinical Pfizer compounds found an increased likelihood of toxic events for less polar, more lipophilic compounds.</li> <li>Compounds with low clogP / high TPSA are \u223c 2.5 times more likely not to have any toxity issue at a fixed concentration of 10 uM (total) or 1 uM (free);</li> <li>Compounds with high clogP / low TPSA are \u223c 2.5 times more likely to have a toxity finding; this represents an overall odds &gt;= 6.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>rop</code> <code>bool</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_reos","title":"<code>rule_of_reos(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, charge=None, n_rotatable_bonds=None, n_heavy_atoms=None, **kwargs)</code>","text":"<p>Compute the REOS filter. The REOS filter is a filter designed to filter out unuseful compounds from HTS screening results. The filter is described in: Waters &amp; Namchuk (2003) Designing screens: how to make your hits a hit.</p> <p>It computes: <code>MW in [200, 500] &amp; logP in [-5, 5] &amp; HBA in [0, 10] &amp; HBD in [0, 5] &amp; charge in [-2, 2] &amp; ROTBONDS in [0, 8] &amp; NHeavyAtoms in [15, 50]</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>charge</code> <code>Optional[int]</code> <p>precomputed formal charge.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds in the molecule.</p> <code>None</code> <code>n_heavy_atoms</code> <code>Optional[int]</code> <p>precomputed number of heavy atoms in the molecule.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ror</code> <code>bool</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_respiratory","title":"<code>rule_of_respiratory(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, tpsa=None, n_rotatable_bonds=None, n_rings=None, **kwargs)</code>","text":"<p>Computes drug likeness rule for Respiratory (nasal/inhalatory) molecules as described in Ritchie et al. (2009) Analysis of the Calculated Physicochemical Properties of Respiratory Drugs: Can We Design for Inhaled Drugs Yet?</p> <p>It computes: <code>MW in [240, 520]  &amp; logP in [-2, 4.7] &amp; HBONDS in [6, 12] &amp; TPSA in [51, 135] &amp; ROTBONDS in [3,8] &amp; RINGS in [1,5]</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed logP.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>tpsa</code> <code>Optional[int]</code> <p>precomputed TPSA.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds in the molecule.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>roc</code> <code>bool</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_three","title":"<code>rule_of_three(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, n_rotatable_bonds=None, **kwargs)</code>","text":"<p>Compute the rule-of-3. The rule-of-three is a rule of thumb for molecular fragments (and not small molecules) published in:</p> <p>Congreve M, Carr R, Murray C, Jhoti H. (2003) <code>A \"rule of three\" for fragment-based lead discovery?</code>.</p> <p>It computes: <code>MW &lt;= 300 &amp; logP &lt;= 3 &amp; HBA &lt;= 3 &amp; HBD &lt;= 3 &amp; ROTBONDS &lt;= 3</code></p> <p>Note</p> <p>TPSA is not used in this version of the rule of three. Other version uses <code>TPSA &lt;= 60 AND logP in [-3, 3]</code> in addition</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds in the molecule.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ro3</code> <code>bool</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_three_extended","title":"<code>rule_of_three_extended(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, tpsa=None, n_rotatable_bonds=None, **kwargs)</code>","text":"<p>Compute the extended rule-of-3. This is an extenion of the rule of three that computes:</p> <p>It computes: <code>MW &lt;= 300 &amp; logP in [-3, 3]  &amp; HBA &lt;= 6 &amp; HBD &lt;= 3 &amp; ROTBONDS &lt;= 3 &amp; TPSA &lt;= 60</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds in the molecule.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ro3</code> <code>bool</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_two","title":"<code>rule_of_two(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, **kwargs)</code>","text":"<p>Computes rules-of-2 for reagent (building block design). It aims for prioritization of reagents that typically do not add more than 200 Da in MW or 2 units of clogP. The rule of two has been described in:</p> <p>Goldberg et al. (2015) Designing novel building blocks is an overlooked strategy to improve compound quality see: http://csmres.co.uk/cs.public.upd/article-downloads/Designing-novel-building-blocks.pdf</p> <p>Note</p> <p>Their analysis showed that molecular weight (MW) and clogP were important factors in the frequency of use of reagents. Other parameters, such as TPSA, HBA, HBD and ROTBONDS count, were less important.</p> <p>It computes <code>MW &lt;= 200 &amp; logP &lt;= 2 &amp; HBA &lt;= 4 &amp; HBD &lt;= 2</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ro2</code> <code>bool</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_veber","title":"<code>rule_of_veber(mol, tpsa=None, n_rotatable_bonds=None, **kwargs)</code>","text":"<p>Compute the Veber filter. The Veber filter is a druglike filter for orally active drugs described in:</p> <p>Veber et. al. (2002) Molecular Properties That Influence the Oral Bioavailability of Drug Candidates.</p> <p>It computes: <code>ROTBONDS &lt;= 10 &amp; TPSA &lt; 140</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>rov</code> <code>bool</code> <p>True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_xu","title":"<code>rule_of_xu(mol, n_hba=None, n_hbd=None, n_rotatable_bonds=None, n_rings=None, n_heavy_atoms=None, **kwargs)</code>","text":"<p>Computes Xu's rule of drug likeness as described in: Xu &amp; Stevenson (2000), Drug-like Index: A New Approach To Measure Drug-like Compounds and Their Diversity</p> <p>It computes <code>HBD &lt;= 5 &amp; HBA &lt;= 10 &amp; ROTBONDS in [2, 35] &amp; RINGS in [1, 7] &amp; NHeavyAtoms in [10, 50]</code>.</p> <p>Note</p> <p>A compound's Drug Likeness Index is calculated based upon the knowledge derived from known drugs selected from Comprehensive Medicinal Chemistry (CMC) database.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds in the molecule.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecule.</p> <code>None</code> <code>n_heavy_atoms</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecule.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code> <p>Returns     rox: True if molecule is compliant, False otherwise</p>"},{"location":"api/medchem.rules.html#medchem.rules.basic_rules.rule_of_zinc","title":"<code>rule_of_zinc(mol, mw=None, clogp=None, n_hba=None, n_hbd=None, tpsa=None, n_rotatable_bonds=None, n_rings=None, charge=None, **kwargs)</code>","text":"<p>Compute the Zinc rule for a molecule. This rule is a rule of thumb to evaluate the druglikeness of a chemical compounds, based on:</p> <p>Irwin &amp; Schoichet (2005) ZINC - A Free Database of Commercially Available Compounds for Virtual Screening.</p> <p>Also see: https://fafdrugs4.rpbs.univ-paris-diderot.fr/filters.html</p> <p>It computes: <code>MW in [60, 600] &amp; logP &lt; in [-4, 6] &amp; HBD &lt;= 6 &amp; HBA &lt;= 11 &amp; TPSA &lt;=150 &amp; ROTBONDS &lt;= 12 &amp; RIGBONDS &lt;= 50 &amp; N_RINGS &lt;= 7 &amp; MAX_SIZE_RING &lt;= 12 &amp; N_CARBONS &gt;=3 &amp; HC_RATIO &lt;= 2.0 &amp; CHARGE in [-4, 4]</code></p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>input molecule</p> required <code>mw</code> <code>Optional[float]</code> <p>precomputed molecular weight.</p> <code>None</code> <code>clogp</code> <code>Optional[float]</code> <p>precomputed cLogP.</p> <code>None</code> <code>n_hba</code> <code>Optional[float]</code> <p>precomputed number of HBA.</p> <code>None</code> <code>n_hbd</code> <code>Optional[float]</code> <p>precomputed number of HBD.</p> <code>None</code> <code>tpsa</code> <code>Optional[float]</code> <p>precomputed TPSA.</p> <code>None</code> <code>n_rotatable_bonds</code> <code>Optional[int]</code> <p>precomputed number of rotatable bonds.</p> <code>None</code> <code>n_rings</code> <code>Optional[int]</code> <p>precomputed number of rings in the molecules.</p> <code>None</code> <code>charge</code> <code>Optional[float]</code> <p>precomputed charge.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Allow extra arguments for descriptors pre-computation.</p> <code>{}</code>"},{"location":"api/medchem.rules.html#utilities","title":"Utilities","text":""},{"location":"api/medchem.rules.html#medchem.rules.in_range","title":"<code>medchem.rules.in_range(x, min_val=-float('inf'), max_val=float('inf'))</code>","text":"<p>Check if a value is in a range</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>value to check</p> required <code>min_val</code> <code>float</code> <p>minimum value</p> <code>-float('inf')</code> <code>max_val</code> <code>float</code> <p>maximum value</p> <code>float('inf')</code>"},{"location":"api/medchem.rules.html#medchem.rules.n_heavy_metals","title":"<code>medchem.rules.n_heavy_metals(mol, allowed_metals=['Li', 'Be', 'K', 'Na', 'Ca', 'Mg'])</code>","text":"<p>Count the number of heavy metals in a molecule</p> <p>Metal are defined using the M notation in marvinjs. It's quicker to exclude atoms than to list all metals</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>input molecule</p> required <code>allowed_metals</code> <code>List[str]</code> <p>list of metals not counted as heavy metals. Default is [\"Li\", \"Be\", \"K\", \"Na\", \"Ca\", \"Mg\"]</p> <code>['Li', 'Be', 'K', 'Na', 'Ca', 'Mg']</code>"},{"location":"api/medchem.rules.html#medchem.rules.has_spider_chains","title":"<code>medchem.rules.has_spider_chains(mol, min_flagel=2, min_flagel_len=4)</code>","text":"<p>Check whether a molecule has multiple flagel like</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>input molecule</p> required <code>min_flagel</code> <code>int</code> <p>minimum number of flagels (&gt;=)</p> <code>2</code> <code>min_flagel_len</code> <code>int</code> <p>minimum length of a flagel (&gt;=)</p> <code>4</code>"},{"location":"api/medchem.rules.html#medchem.rules.n_fused_aromatic_rings","title":"<code>medchem.rules.n_fused_aromatic_rings(mol, require_all_aromatic=True, pairwise=False)</code>","text":"<p>Count the number of fused aromatic rings in a molecule</p> <p>Warning</p> <p>There is no such thing as a spiroaoaromatic ring in this implementation</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>input molecule</p> required <code>require_all_aromatic</code> <code>bool</code> <p>whether to require all simple rings in the fused system to be aromatic</p> <code>True</code> <code>pairwise</code> <code>bool</code> <p>whether to compute the number of fused aromatic rings pairwise. meaning phenanthrene and anthracene would count for 2 fused aromatic rings each</p> <code>False</code>"},{"location":"api/medchem.rules.html#medchem.rules.fraction_atom_in_scaff","title":"<code>medchem.rules.fraction_atom_in_scaff(mol)</code>","text":"<p>Compute the fraction of atoms that belong to any ring system of the molecule as defined by the scaffold</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>dm.Mol</code> <p>input molecule</p> required"},{"location":"api/medchem.rules.html#medchem.rules.list_descriptors","title":"<code>medchem.rules.list_descriptors()</code>","text":"<p>List all descriptors available for computation</p>"},{"location":"api/medchem.structural.html","title":"<code>medchem.structural</code>","text":""},{"location":"api/medchem.structural.html#medchem.structural.CommonAlertsFilters","title":"<code>medchem.structural.CommonAlertsFilters</code>","text":"<p>Filtering class for building a library based on a list of structural alerts</p> <p>To list the available alerts, use the <code>list_default_available_alerts</code> method.</p>"},{"location":"api/medchem.structural.html#medchem.structural._common.CommonAlertsFilters.__call__","title":"<code>__call__(mols, n_jobs=-1, progress=False, progress_leave=False, scheduler='auto', keep_details=False)</code>","text":"<p>Run alert evaluation on this list of molecule and return the full dataframe</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecule object.</p> required <code>n_jobs</code> <code>Optional[int]</code> <p>number of jobs to run in parallel.</p> <code>-1</code> <code>progress</code> <code>bool</code> <p>whether to show progress or not.</p> <code>False</code> <code>progress_leave</code> <code>bool</code> <p>whether to leave the progress bar or not.</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>which scheduler to use. If \"auto\", will use \"processes\" if <code>len(mols) &gt; 500</code> else \"threads\".</p> <code>'auto'</code> <code>keep_details</code> <code>bool</code> <p>whether to keep the details of the evaluation or not.</p> <code>False</code>"},{"location":"api/medchem.structural.html#medchem.structural._common.CommonAlertsFilters.__init__","title":"<code>__init__(alerts_set=None, alerts_db_path=None)</code>","text":"<p>Filtering molecules based on chemical alerts</p> <p>Parameters:</p> Name Type Description Default <code>alerts_set</code> <code>Optional[Union[str, List[str]]]</code> <p>Filter set to use. Default is BMS+Dundee+Glaxo.</p> <code>None</code> <code>alerts_db_path</code> <code>Optional[Union[os.PathLike, str]]</code> <p>Alerts file to use. Default is internal.</p> <code>None</code>"},{"location":"api/medchem.structural.html#medchem.structural._common.CommonAlertsFilters.list_default_available_alerts","title":"<code>list_default_available_alerts()</code>  <code>cached</code> <code>staticmethod</code>","text":"<p>Return a list of unique rule set names</p>"},{"location":"api/medchem.structural.html#medchem.structural.NIBRFilters","title":"<code>medchem.structural.NIBRFilters</code>","text":"<p>Filtering class for building a screening deck following the novartis filtering process published in https://dx.doi.org/10.1021/acs.jmedchem.0c01332.</p> <p>The output of the filter are explained below: - status: one of <code>[\"exclude\", \"flag\", \"annotations\", \"ok\"]</code> (ordered by quality).     Generally, you can keep anything without the \"exclude\" label, as long as you also apply     a maximum severity score for compounds that collects too many flags. - n_covalent_motif: number of potentially covalent motifs contained in the compound - severity: how severe are the issues with the molecules:     - <code>0</code>: compound has no flags, might have annotations;     - <code>1-9</code>:  number of flags the compound raises;     - <code>&gt;= 10</code>:  default exclusion criterion used in the paper - special_mol: whether the compound/parts of the compound belongs to a special class of molecules     (e.g peptides, glycosides, fatty acid). In that case, you should review the rejection reasons.</p>"},{"location":"api/medchem.structural.html#medchem.structural._nibr.NIBRFilters.__call__","title":"<code>__call__(mols, n_jobs=-1, progress=False, progress_leave=False, scheduler='threads', keep_details=False)</code>","text":"<p>Run alert evaluation on this list of molecule and return the full dataframe</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>Sequence[Union[str, dm.Mol]]</code> <p>list of input molecule object.</p> required <code>n_jobs</code> <code>Optional[int]</code> <p>number of jobs to run in parallel.</p> <code>-1</code> <code>progress</code> <code>bool</code> <p>whether to show progress or not.</p> <code>False</code> <code>progress_leave</code> <code>bool</code> <p>whether to leave the progress bar or not.</p> <code>False</code> <code>scheduler</code> <code>str</code> <p>which scheduler to use. The <code>processes</code> scheduler works but is very inefficient due to RDKit Catalog serialization which tends to be very slow.</p> <code>'threads'</code> <code>keep_details</code> <code>bool</code> <p>whether to keep the details of the evaluation or not.</p> <code>False</code>"},{"location":"api/medchem.structural.html#medchem.structural.lilly_demerits.LillyDemeritsFilters","title":"<code>medchem.structural.lilly_demerits.LillyDemeritsFilters</code>","text":""},{"location":"api/medchem.structural.html#medchem.structural.lilly_demerits._demerits.LillyDemeritsFilters.__init__","title":"<code>__init__(mc_first_pass_options=None, iwd_options=None, stop_after_step=3, **run_options)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>mc_first_pass_options</code> <code>Optional[str]</code> <p>Initial options to pass to mc_first_pass</p> <code>None</code> <code>iwd_options</code> <code>Optional[str]</code> <p>Initial options to pass to iwdemerit</p> <code>None</code> <code>stop_after_step</code> <code>int</code> <p>Where to stop in the pipeline. Don't change this if you don't know.</p> <code>3</code> <code>run_options</code> <code>Any</code> <p>Additional option to run the pipeline</p> <code>{}</code>"},{"location":"api/medchem.utils.html","title":"<code>medchem.utils</code>","text":""},{"location":"api/medchem.utils.html#medchem.utils.smarts","title":"<code>medchem.utils.smarts</code>","text":""},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils","title":"<code>SMARTSUtils</code>","text":"<p>Collections of utils to build complex SMARTS query more efficiently for non experienced user</p>"},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils.aliphatic_chain","title":"<code>aliphatic_chain(min_size=6, unbranched=False, unsaturated_bondtype=None, allow_hetero_atoms=True)</code>  <code>classmethod</code>","text":"<p>Returns a query that can match a long aliphatic chain</p> <p>Parameters:</p> Name Type Description Default <code>min_size</code> <code>int</code> <p>minimum size of the long chain</p> <code>6</code> <code>unbranched</code> <code>bool</code> <p>whether the chain should be unbranched</p> <code>False</code> <code>unsaturated_bondtype</code> <code>Optional[str]</code> <p>additional unsaturated bond type to use for the query. By default, Any bond type (~) is used. Single bonds ARE always allowed and bondtype cannot be aromatic</p> <code>None</code> <code>allow_hetero_atoms</code> <code>bool</code> <p>whether the chain can contain hetero atoms</p> <code>True</code> Example <p>to build a query for a long aliphatic chain of a least 5 atoms (e.g: 'CCC(C)CCC')</p> <p>SMARTSUtils.aliphatic_chain(min_size=5)</p> <p>Returns:</p> Name Type Description <code>smarts</code> <code>str</code> <p>smarts pattern matching a long aliphatic chain</p>"},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils.atom_in_env","title":"<code>atom_in_env(*smarts_strs, include_atoms=False, union=False)</code>  <code>classmethod</code>","text":"<p>Returns a recursive/group smarts to find an atom that fits in the environments as defined by all the input smarts</p> <p>Parameters:</p> Name Type Description Default <code>smarts_strs</code> <code>str</code> <p>list of input patterns defining the environment the atom must fit in. The first atom of each pattern should be the atom we want to match to, unless include_atoms is set to True, then [*:99] will be added at the start of each pattern</p> <code>()</code> <code>include_atoms</code> <code>bool</code> <p>whether to include an additional first atom that needs to be in the required environment or not</p> <code>False</code> <code>union</code> <code>bool</code> <p>whether to use the union of the environments or the intersection</p> <code>False</code> Example <p>you can use this function to construct a complex query if you are not sure about how to write the smarts for example, to find a carbon atom that is both in a ring or size 6, bonded to an ethoxy and have a Fluorine in meta</p> <pre><code>SMARTSUtils.atom_in_env(\"[#6;r6][OD2][C&amp;D1]\", \"[c]aa[F]\", union=False) # there are alternative way to write this\n</code></pre> <p>Returns:</p> Name Type Description <code>smarts</code> <code>str</code> <p>smarts pattern matching the group/environment</p>"},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils.meta","title":"<code>meta(smarts_str1, smarts_str2, aromatic_only=False)</code>  <code>classmethod</code>","text":"<p>Returns a recursive smarts string connecting the two input smarts in <code>meta</code> of each other. Connexion points needs to be through single or double bonds</p> <p>Parameters:</p> Name Type Description Default <code>smarts_str1</code> <code>str</code> <p>first smarts pattern defining the first functional group</p> required <code>smarts_str2</code> <code>str</code> <p>second smarts pattern defining the second functional group</p> required <code>aromatic_only</code> <code>bool</code> <p>whether the ring needs to be aromatic or not</p> <code>False</code> Example <p>to build a smarts for a methyl group in meta to an oxygen (e.g: 'c1c(C)cc(O)cc1')</p> <p>SMARTSUtils.meta('[#6;!R]', '[#8]')</p> <p>Returns:</p> Name Type Description <code>smarts</code> <code>str</code> <p>smarts pattern connecting the two input smarts in <code>meta</code> of each other</p>"},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils.ortho","title":"<code>ortho(smarts_str1, smarts_str2, aromatic_only=False)</code>  <code>classmethod</code>","text":"<p>Returns a recursive smarts string connecting the two input smarts in <code>ortho</code> of each other. Connexion points needs to be through single or double bonds</p> <p>Parameters:</p> Name Type Description Default <code>smarts_str1</code> <code>str</code> <p>first smarts pattern defining the first functional group</p> required <code>smarts_str2</code> <code>str</code> <p>second smarts pattern defining the second functional group</p> required <code>aromatic_only</code> <code>bool</code> <p>whether the ring needs to be aromatic or not</p> <code>False</code> Example <p>to build a smarts for a methyl group in ortho to an oxygen (e.g: 'C1CC(C)C(O)CC1')</p> <p>SMARTSUtils.ortho('[#6;!R]', '[#8]')</p> <p>Returns:</p> Name Type Description <code>smarts</code> <code>str</code> <p>smarts pattern connecting the two input smarts in <code>ortho</code> of each other</p>"},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils.para","title":"<code>para(smarts_str1, smarts_str2, aromatic_only=False)</code>  <code>classmethod</code>","text":"<p>Returns a recursive smarts string connecting the two input smarts in <code>para</code> of each other. Connexion points needs to be through single or double bonds</p> <p>Parameters:</p> Name Type Description Default <code>smarts_str1</code> <code>str</code> <p>first smarts pattern defining the first functional group</p> required <code>smarts_str2</code> <code>str</code> <p>second smarts pattern defining the second functional group</p> required <code>aromatic_only</code> <code>bool</code> <p>whether the ring needs to be aromatic or not</p> <code>False</code> Example <p>to build a smarts for a methyl group in para to an oxygen (e.g: 'c1(C)ccc(O)cc1')</p> <p>SMARTSUtils.para('[#6;!R]', '[#8]')</p> <p>Returns:</p> Name Type Description <code>smarts</code> <code>str</code> <p>smarts pattern connecting the two input smarts in <code>para</code> of each other</p>"},{"location":"api/medchem.utils.html#medchem.utils.smarts.SMARTSUtils.standardize_attachment","title":"<code>standardize_attachment(smiles, attach_tokens='[*:1]')</code>  <code>classmethod</code>","text":"<p>Standardize an attachment point in a smiles</p> <p>Parameters:</p> Name Type Description Default <code>smiles</code> <code>str</code> <p>SMILES string</p> required <code>attach_tokens</code> <code>str</code> <p>Attachment point token to use as standard token</p> <code>'[*:1]'</code>"},{"location":"api/medchem.utils.html#medchem.utils.loader","title":"<code>medchem.utils.loader</code>","text":""},{"location":"api/medchem.utils.html#medchem.utils.loader.get_data_path","title":"<code>get_data_path(filename, module='medchem.data')</code>  <code>cached</code>","text":"<p>Return the filepath of a data file.</p>"},{"location":"api/medchem.utils.html#medchem.utils.loader.get_grammar","title":"<code>get_grammar(grammar=None, as_string=False)</code>","text":"<p>Return the default lark grammar file for queries</p> <p>Parameters:</p> Name Type Description Default <code>grammar</code> <code>Optional[Union[os.PathLike, str]]</code> <p>The path to the grammar file. If None, the default medchem grammar file is used.</p> <code>None</code> <code>as_string</code> <code>bool</code> <p>If True, return the grammar as a string. Defaults to False.</p> <code>False</code>"},{"location":"api/medchem.utils.html#medchem.utils.graph","title":"<code>medchem.utils.graph</code>","text":""},{"location":"api/medchem.utils.html#medchem.utils.graph.automorphism","title":"<code>automorphism(mol, standardize=True, node_attrs=DEFAULT_NODE_ATTR, edge_attrs=DEFAULT_EDGE_ATTR)</code>","text":"<p>Compute automorphism in a molecular graph</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[str, dm.Mol]</code> <p>input molecular graph</p> required <code>standardize</code> <code>bool</code> <p>whether to standardize the compound or not</p> <code>True</code> <code>node_attrs</code> <code>List[str]</code> <p>list of categorical atom attributes/properties to consider for node matching</p> <code>DEFAULT_NODE_ATTR</code> <code>edge_attrs</code> <code>List[str]</code> <p>list of categorical bond attributes/properties to consider for edge matching</p> <code>DEFAULT_EDGE_ATTR</code>"},{"location":"api/medchem.utils.html#medchem.utils.graph.score_symmetry","title":"<code>score_symmetry(mol, exclude_self_mapped_edged=False, **automorphism_kwargs)</code>","text":"<p>Provide a symmetry score for a given input molecule</p> <p>Note</p> <p>This is an heuristic and our definition of symmetry is pretty loose. We define symmetry according to any (set of) plans dividing the molecule into two very similar subgraph. We include both edge and vertex transitivity. For example the star-molecular graph (e.g neopentane) is symmetrical here, although it's not vertex-transitive.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[dm.Mol, str]</code> <p>inputs molecules</p> required <code>exclude_self_mapped_edged</code> <code>bool</code> <p>Whether to exclude edges that matches to themselves in automorphism.</p> <code>False</code> <code>automorphism_kwargs</code> <code>Any</code> <p>keyword for determining automorphism</p> <code>{}</code>"},{"location":"tutorials/Catalogs.html","title":"Catalogs","text":"In\u00a0[1]: Copied! <pre>import datamol as dm\nimport pandas as pd\n\nimport medchem as mc\nfrom medchem.catalogs import NamedCatalogs\nfrom medchem.catalogs import list_named_catalogs\nfrom medchem.catalogs import catalog_from_smarts\n</pre> import datamol as dm import pandas as pd  import medchem as mc from medchem.catalogs import NamedCatalogs from medchem.catalogs import list_named_catalogs from medchem.catalogs import catalog_from_smarts <p>List all the available catalogs.</p> In\u00a0[2]: Copied! <pre>list_named_catalogs()\n</pre> list_named_catalogs() Out[2]: <pre>['tox',\n 'pains',\n 'pains_a',\n 'pains_b',\n 'pains_c',\n 'nih',\n 'zinc',\n 'brenk',\n 'dundee',\n 'bms',\n 'glaxo',\n 'schembl',\n 'mlsmr',\n 'inpharmatica',\n 'lint',\n 'alarm_nmr',\n 'alphascreen',\n 'gst_hitters',\n 'his_hitters',\n 'luciferase',\n 'dnabinder',\n 'chelator',\n 'hitters',\n 'electrophilic',\n 'carcinogen',\n 'ld50_oral',\n 'reactive_unstable_toxic',\n 'skin',\n 'toxicophore',\n 'nibr',\n 'bredt',\n 'unstable_graph']</pre> <p>Retrieve a specific catalog as an RDKit catalog object.</p> In\u00a0[9]: Copied! <pre>catalog = NamedCatalogs.nibr()\n\ncatalog.GetNumEntries()\n</pre> catalog = NamedCatalogs.nibr()  catalog.GetNumEntries() Out[9]: <pre>444</pre> <p>This catalog has 444 entries.</p> <p>Now, let's load some molecules and check whether they match to the NIBR catalog.</p> In\u00a0[11]: Copied! <pre>data = dm.freesolv()\ndata = data.iloc[:50]\n\ndata[\"mol\"] = data[\"smiles\"].apply(dm.to_mol)\n\ndata[\"match_nibr_catalog\"] = data[\"mol\"].apply(catalog.HasMatch)\n</pre> data = dm.freesolv() data = data.iloc[:50]  data[\"mol\"] = data[\"smiles\"].apply(dm.to_mol)  data[\"match_nibr_catalog\"] = data[\"mol\"].apply(catalog.HasMatch) <p>Pick a few to display.</p> In\u00a0[12]: Copied! <pre>rows = data.sample(n=8, random_state=19)\n\nmols = rows[\"mol\"].tolist()\nlegends = rows[\"match_nibr_catalog\"].apply(lambda x: f\"Match={x}\").tolist()\n\ndm.to_image(mols, legends=legends, mol_size=(300, 200))\n</pre> rows = data.sample(n=8, random_state=19)  mols = rows[\"mol\"].tolist() legends = rows[\"match_nibr_catalog\"].apply(lambda x: f\"Match={x}\").tolist()  dm.to_image(mols, legends=legends, mol_size=(300, 200)) Out[12]: <p>It's possible to retrieve the entries that match a certain molecule.</p> In\u00a0[13]: Copied! <pre>mol = dm.to_mol(\"c1cc(c(cc1Cl)Cl)Cl\")\n\nmol\n</pre> mol = dm.to_mol(\"c1cc(c(cc1Cl)Cl)Cl\")  mol Out[13]: In\u00a0[7]: Copied! <pre>matches = catalog.GetMatches(mol)\n[m.GetDescription() for m in matches]\n</pre> matches = catalog.GetMatches(mol) [m.GetDescription() for m in matches] Out[7]: <pre>['NIBR||halogen_aromatic_count_3_min(3)||0||0||0',\n 'NIBR||polyhalogenated_aromate_min(1)||1||0||0']</pre> <p>First, build a list of SMARTS.</p> In\u00a0[8]: Copied! <pre>smarts_list = [\n    [\"HBA\", \"[!$([#6,F,Cl,Br,I,o,s,nX3,#7v5,#15v5,#16v4,#16v6,*+1,*+2,*+3])]\"],\n    [\"Acid\", \"[CX3](=O)[OX1H0-,OX2H1]\"],\n    [\"Macrocycle\", \"[r;!r3;!r4;!r5;!r6;!r7]\"],\n    [\"Benzene\", \"[cR1]1[cR1][cR1][cR1][cR1][cR1]1\"],\n    [\"Halogen\", \"[F,Cl,Br,I]\"],\n]\n\nnames, smarts = list(zip(*smarts_list))\n</pre> smarts_list = [     [\"HBA\", \"[!$([#6,F,Cl,Br,I,o,s,nX3,#7v5,#15v5,#16v4,#16v6,*+1,*+2,*+3])]\"],     [\"Acid\", \"[CX3](=O)[OX1H0-,OX2H1]\"],     [\"Macrocycle\", \"[r;!r3;!r4;!r5;!r6;!r7]\"],     [\"Benzene\", \"[cR1]1[cR1][cR1][cR1][cR1][cR1]1\"],     [\"Halogen\", \"[F,Cl,Br,I]\"], ]  names, smarts = list(zip(*smarts_list)) <p>Now build the catalog object from it.</p> In\u00a0[17]: Copied! <pre>custom_catalog = catalog_from_smarts(\n    smarts=smarts,\n    labels=names,\n    entry_as_inds=False,\n)\n</pre> custom_catalog = catalog_from_smarts(     smarts=smarts,     labels=names,     entry_as_inds=False, ) <p>Check how many entries.</p> In\u00a0[18]: Copied! <pre>custom_catalog.GetNumEntries()\n</pre> custom_catalog.GetNumEntries() Out[18]: <pre>5</pre> <p>You're good to use it!</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/Catalogs.html#catalogs","title":"Catalogs\u00b6","text":"<p>Medchem proposes a list of RDKit-based catalogs and Medchem-specific catalogs in order to quickly triage or flag compounds that contains a molecular features within a given catalog.</p> <p>The API is based on the RDKit catalog module <code>rdkit.Chem.rdfiltercatalog</code>.</p>"},{"location":"tutorials/Catalogs.html#use-the-existing-catalogs","title":"Use the existing catalogs\u00b6","text":""},{"location":"tutorials/Catalogs.html#build-your-own-catalog","title":"Build your own catalog\u00b6","text":""},{"location":"tutorials/Chemical_Groups.html","title":"Chemical Groups","text":"In\u00a0[2]: Copied! <pre>import datamol as dm\nimport pandas as pd\n\nimport medchem\nfrom medchem.groups import ChemicalGroup\n</pre> import datamol as dm import pandas as pd  import medchem from medchem.groups import ChemicalGroup In\u00a0[4]: Copied! <pre>medchem.groups.list_default_chemical_groups()\n</pre> medchem.groups.list_default_chemical_groups() Out[4]: <pre>['emerging_perfluoroalkyls',\n 'montmorillonite_adsorption',\n 'common_monomer_repeating_units',\n 'electrophilic_warheads_for_kinases',\n 'common_warhead_covalent_inhibitors',\n 'rings_in_drugs',\n 'iupac_blue_book_rings',\n 'phase_2_hetereocyclic_rings',\n 'privileged_scaffolds',\n 'iupac_blue_book',\n 'common_rgroup_replacements',\n 'braf_inhibitors',\n 'privileged_kinase_inhibitor_scaffolds',\n 'common_organic_solvents',\n 'amino_acid_protecting_groups',\n 'schedule_one',\n 'schedule_two',\n 'schedule_three',\n 'schedule_four',\n 'schedule_five',\n 'interstellar_space',\n 'vitamins',\n 'open_smiles',\n 'amino_acids',\n 'pihkal',\n 'aggregator',\n 'basic_groups',\n 'extended_groups',\n 'hinge_binders']</pre> <p>List common functional group names. The list is too long to we only show a few elements.</p> In\u00a0[17]: Copied! <pre>medchem.groups.list_functional_group_names()[40:50]\n</pre> medchem.groups.list_functional_group_names()[40:50] Out[17]: <pre>['acidic groups',\n 'acidic groups',\n 'acidic groups',\n 'acidic groups',\n 'Carbonyl compouns: aldehydes or ketones',\n 'Aldehydes',\n 'Ketones',\n 'Thiocarbonyl compounds: thioaldehydes or thioketones',\n 'Thioaldehydes',\n 'Thioketones']</pre> <p>You can also retrieve a <code>dict</code> of functional group to their SMARTS. Here again we only show a small subset.</p> In\u00a0[16]: Copied! <pre>fg_map = medchem.groups.get_functional_group_map()\n\ndict(list(fg_map.items())[:10])\n</pre> fg_map = medchem.groups.get_functional_group_map()  dict(list(fg_map.items())[:10]) Out[16]: <pre>{'primary_amine': '[NH]=C([NH2])[NH]C[NH]',\n 'secondary_amine': 'c[OX2][CX4;!R][CX4;!R]([OH])[CX4;!R][NH][CH]([CH3])[CH3]',\n 'tertiary_amine': '[CH3][N;!+]([CH3])[CX4;R][CX4;R]([CH3])[OX2;R]',\n 'cyclic_amine': '[CH3][N;R!+]([CX4;R])[CX4;R]',\n 'aromatic_system': 'c[CH]([N;R])c',\n 'ring_system': '[R;!a]',\n 'acidic groups': '[#6][N+](=O)[O-]',\n 'Carbonyl compouns: aldehydes or ketones': '[$([H][CX3]([#1,#6])=[OX1]),$([#6&amp;!$(C#N)][CX3](=[OX1])[#6&amp;!$(C#N)])]',\n 'Aldehydes': '[H][CX3]([#1,#6])=[OX1]',\n 'Ketones': '[#6&amp;!$(C#N)][CX3](=[OX1])[#6&amp;!$(C#N)]'}</pre> In\u00a0[23]: Copied! <pre>group = ChemicalGroup(groups=[\"basic_groups\", \"rings_in_drugs\"])\n\ngroup\n</pre> group = ChemicalGroup(groups=[\"basic_groups\", \"rings_in_drugs\"])  group Out[23]: <pre>&lt;medchem.groups._groups.ChemicalGroup at 0x7fa4c4413b10&gt;</pre> <p>The groups are part of a hierarchy you can explore with:</p> In\u00a0[28]: Copied! <pre>group.list_hierarchy_groups()\n</pre> group.list_hierarchy_groups() Out[28]: <pre>['medicinal_chemistry.rings.rings_in_drugs.rings_in_drugs',\n 'medicinal_chemistry.functional_groups.basic_groups']</pre> <p>Check whether a molecule match with the created group.</p> In\u00a0[29]: Copied! <pre>mol = dm.to_mol(\"CCS(=O)(=O)N1CC(C1)(CC#N)N2C=C(C=N2)C3=C4C=CNC4=NC=N3\")\n\nmol\n</pre> mol = dm.to_mol(\"CCS(=O)(=O)N1CC(C1)(CC#N)N2C=C(C=N2)C3=C4C=CNC4=NC=N3\")  mol Out[29]: In\u00a0[32]: Copied! <pre>group.get_matches(mol, use_smiles=True)\n</pre> group.get_matches(mol, use_smiles=True) Out[32]: name smiles smarts group matches 204 diazine C1=NC=CC=N1 [#6]1:[#7]:[#6]:[#6]:[#6]:[#7]:1 rings_in_drugs ((24, 23, 22, 18, 17, 25),) 234 1H-pyrazole N1=CC=CN1 [#7]1:[#6]:[#6]:[#6]:[#7H]:1 rings_in_drugs ((12, 13, 14, 15, 16),) 257 1H-pyrrole C1=CC=CN1 [#6]1:[#6]:[#6]:[#6]:[#7H]:1 rings_in_drugs ((20, 19, 18, 22, 21),) <p>You can also display all the filters for a given group.</p> In\u00a0[36]: Copied! <pre>group.data.head()\n</pre> group.data.head() Out[36]: name smiles smarts group hierarchy mol_smarts mol 191 benzene C1=CC=CC=C1 [#6]1:[#6]:[#6]:[#6]:[#6]:[#6]:1 rings_in_drugs medicinal_chemistry.rings.rings_in_drugs.rings... &lt;rdkit.Chem.rdchem.Mol object at 0x7fa4c4165c40&gt; &lt;rdkit.Chem.rdchem.Mol object at 0x7fa4c41698c0&gt; 192 pyridine C1=CC=CN=C1 [#6]1:[#6]:[#6]:[#6]:[#7]:[#6]:1 rings_in_drugs medicinal_chemistry.rings.rings_in_drugs.rings... &lt;rdkit.Chem.rdchem.Mol object at 0x7fa4c4165cb0&gt; &lt;rdkit.Chem.rdchem.Mol object at 0x7fa4c4169930&gt; 193 piperidine N1CCCCC1 [#7]1-[#6]-[#6]-[#6]-[#6]-[#6]-1 rings_in_drugs medicinal_chemistry.rings.rings_in_drugs.rings... &lt;rdkit.Chem.rdchem.Mol object at 0x7fa4c4165d20&gt; &lt;rdkit.Chem.rdchem.Mol object at 0x7fa4c41699a0&gt; 194 piperazine N1CCNCC1 [#7]1-[#6]-[#6]-[#7]-[#6]-[#6]-1 rings_in_drugs medicinal_chemistry.rings.rings_in_drugs.rings... &lt;rdkit.Chem.rdchem.Mol object at 0x7fa4c4165d90&gt; &lt;rdkit.Chem.rdchem.Mol object at 0x7fa4c4169a10&gt; 195 cyclohexane C1CCCCC1 [#6]1-[#6]-[#6]-[#6]-[#6]-[#6]-1 rings_in_drugs medicinal_chemistry.rings.rings_in_drugs.rings... &lt;rdkit.Chem.rdchem.Mol object at 0x7fa4c4165e00&gt; &lt;rdkit.Chem.rdchem.Mol object at 0x7fa4c4169a80&gt; <p>Groups are organized as a hierarchy. It's possible to load many groups at once.</p> In\u00a0[40]: Copied! <pre>medchem.groups.list_default_chemical_groups(hierarchy=True)[:20]\n</pre> medchem.groups.list_default_chemical_groups(hierarchy=True)[:20] Out[40]: <pre>['environment.emerging_perfluoroalkyls.emerging_perfluoroalkyls',\n 'materials.clay.montmorillonite_adsorption.montmorillonite_adsorption',\n 'materials.polymers.common_monomer_repeating_units.common_monomer_repeating_units',\n 'medicinal_chemistry.warheads.electrophillic_warheads_for_kinases.electrophilic_warheads_for_kinases',\n 'medicinal_chemistry.warheads.common_warheads_covalent_inhibitors.common_warhead_covalent_inhibitors',\n 'medicinal_chemistry.rings.rings_in_drugs.rings_in_drugs',\n 'medicinal_chemistry.rings.iupac_blue_book_rings.iupac_blue_book_rings',\n 'medicinal_chemistry.rings.phase_2_hetereocyclic_rings.phase_2_hetereocyclic_rings',\n 'medicinal_chemistry.scaffolds.privileged_scaffolds.privileged_scaffolds',\n 'medicinal_chemistry.scaffolds.iupac_blue_book_substituents.iupac_blue_book',\n 'medicinal_chemistry.scaffolds.common_r_group_replacements.common_rgroup_replacements',\n 'proteins.kinases.braf.inhibitors.braf_inhibitors',\n 'proteins.kinases.scaffolds.privileged_kinase_inhibtors.privileged_kinase_inhibitor_scaffolds',\n 'organic_synthesis.solvents.common_organic_solvents.common_organic_solvents',\n 'organic_synthesis.protecting_groups.amino_acid_protecting_groups.amino_acid_protecting_groups',\n 'narcotics.schedule_one.schedule_one',\n 'narcotics.schedule_two.schedule_two',\n 'narcotics.schedule_three.schedule_three',\n 'narcotics.schedule_four.schedule_four',\n 'narcotics.schedule_five.schedule_five']</pre> <p>For example you can load all the hinge binder groups with:</p> In\u00a0[50]: Copied! <pre>group = ChemicalGroup(\"hinge_binders*\")\n\ngroup.list_hierarchy_groups()[:10]\n</pre> group = ChemicalGroup(\"hinge_binders*\")  group.list_hierarchy_groups()[:10] Out[50]: <pre>['medicinal_chemistry.chemotype.kinases.NAK.hinge_binders',\n 'medicinal_chemistry.chemotype.kinases.ABL.hinge_binders',\n 'medicinal_chemistry.chemotype.kinases.ACK.hinge_binders',\n 'medicinal_chemistry.chemotype.kinases.STKR.hinge_binders',\n 'medicinal_chemistry.chemotype.kinases.AKT.hinge_binders',\n 'medicinal_chemistry.chemotype.kinases.ALK.hinge_binders',\n 'medicinal_chemistry.chemotype.kinases.AUR.hinge_binders',\n 'medicinal_chemistry.chemotype.kinases.GRK.hinge_binders',\n 'medicinal_chemistry.chemotype.kinases.RAF.hinge_binders',\n 'medicinal_chemistry.chemotype.kinases.SRC.hinge_binders']</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/Chemical_Groups.html#chemical-groups","title":"Chemical Groups\u00b6","text":"<p>The <code>medchem.groups</code> module contains a large list of chemical and functional groups to classify compounds. Its easy-to-use API allows you to specify either a whole family or a subset of chemical groups. For example, you can load all the known hinge binders motifs with <code>ChemicalGroup(\"hinge_binders*\")</code>.</p>"},{"location":"tutorials/Chemical_Groups.html#list-the-available-chemical-and-functional-groups","title":"List the available chemical and functional groups\u00b6","text":"<p>List the default chemical groups</p>"},{"location":"tutorials/Chemical_Groups.html#load-one-ore-more-groups-and-filter-a-list-of-molecules","title":"Load one ore more groups and filter a list of molecules\u00b6","text":""},{"location":"tutorials/Chemical_Groups.html#load-groups-from-a-hierarchy","title":"Load groups from a hierarchy\u00b6","text":""},{"location":"tutorials/Constraints_Filtering.html","title":"Constraints Filtering","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n    \nimport datamol as dm\nimport pandas as pd\n\nimport medchem\n</pre> %load_ext autoreload %autoreload 2      import datamol as dm import pandas as pd  import medchem In\u00a0[2]: Copied! <pre>def my_constraints(mol):\n    # we want to match either (have phenol) OR (have less than 7 atoms and not ring)\n    return mol.HasSubstructMatch(dm.to_mol(\"Oc1ccccc1\")) or (\n        mol.GetNumAtoms() &lt; 7 and dm.descriptors.n_rings(mol) &lt; 1\n    )\n\n\nsmiles = [\n    \"CN(C)C(=O)c1cncc(C)c1\",  # match, n_atoms &lt; 7 and no ring\n    \"Cc1cncc(CC2CCCCC2)c1\",  # not match, n_atoms &lt; 7 but ring\n    \"Cc1cncc(c1)-c1ccc(O)cc1\",  # match phenol\n    \"Cc1cncc(c1)-c1cccc2nc[nH]c12\",  # no match n_atoms &gt;= 7\n]\n\nexpected_results = []\nmols = [dm.to_mol(x) for x in smiles]\n\ndm.to_image(mols)\n</pre> def my_constraints(mol):     # we want to match either (have phenol) OR (have less than 7 atoms and not ring)     return mol.HasSubstructMatch(dm.to_mol(\"Oc1ccccc1\")) or (         mol.GetNumAtoms() &lt; 7 and dm.descriptors.n_rings(mol) &lt; 1     )   smiles = [     \"CN(C)C(=O)c1cncc(C)c1\",  # match, n_atoms &lt; 7 and no ring     \"Cc1cncc(CC2CCCCC2)c1\",  # not match, n_atoms &lt; 7 but ring     \"Cc1cncc(c1)-c1ccc(O)cc1\",  # match phenol     \"Cc1cncc(c1)-c1cccc2nc[nH]c12\",  # no match n_atoms &gt;= 7 ]  expected_results = [] mols = [dm.to_mol(x) for x in smiles]  dm.to_image(mols) Out[2]: In\u00a0[3]: Copied! <pre>core = dm.from_smarts(\"[C;H3]c1cncc([*:1])c1\")\n\ncore\n</pre> core = dm.from_smarts(\"[C;H3]c1cncc([*:1])c1\")  core Out[3]: In\u00a0[4]: Copied! <pre># now let's set the constraints query at the query atom of the code\n# At atom map num 1, we want the fragment matching to have additional properties\nfor atom in core.GetAtoms():\n    # we add a recursive query to check again on any match that starts with this atom position\n    if atom.GetAtomMapNum() == 1:\n        atom.SetProp(\"query\", \"my_constraint\")\n</pre> # now let's set the constraints query at the query atom of the code # At atom map num 1, we want the fragment matching to have additional properties for atom in core.GetAtoms():     # we add a recursive query to check again on any match that starts with this atom position     if atom.GetAtomMapNum() == 1:         atom.SetProp(\"query\", \"my_constraint\") In\u00a0[5]: Copied! <pre># Create the constraints object\nconstraint_fns = {\"my_constraint\": my_constraints}\nconstraint = medchem.constraints.Constraints(core, constraint_fns)\n\n# Check against our list of molecules\nmatches = [constraint(mol) for mol in mols]\n\nmatches\n</pre> # Create the constraints object constraint_fns = {\"my_constraint\": my_constraints} constraint = medchem.constraints.Constraints(core, constraint_fns)  # Check against our list of molecules matches = [constraint(mol) for mol in mols]  matches Out[5]: <pre>[True, False, True, False]</pre> In\u00a0[6]: Copied! <pre>legends = [f\"Do match={m}\" for m in matches]\n\ndm.to_image(mols, legends=legends)\n</pre> legends = [f\"Do match={m}\" for m in matches]  dm.to_image(mols, legends=legends) Out[6]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/Constraints_Filtering.html#constraints-filtering","title":"Constraints Filtering\u00b6","text":"<p>The <code>medchem.constraints.Constraints</code> module allows to easily filter based on complex structural constraints that cannot be captured by SMARTS and basic molecular properties rules.</p>"},{"location":"tutorials/Medchem_Query_Language.html","title":"Medchem Query Language","text":"In\u00a0[1]: Copied! <pre>import datamol as dm\nimport pandas as pd\n\nimport medchem as mc\n</pre> import datamol as dm import pandas as pd  import medchem as mc In\u00a0[18]: Copied! <pre># note that whitespace and newlines are ignored in the query\nquery = \"\"\"\n(\n    HASPROP(\"tpsa\" &lt; 80) AND HASPROP(\"clogp\" &lt; 3) AND ! HASALERT(\"pains\")\n) \n    OR \n(\n    HASPROP(\"n_heavy_atoms\" &gt;= 10) \n    AND \n    (\n        HASGROUP(\"Alcohols\") \n        OR \n        HASSUBSTRUCTURE(\"[CX3](=[OX1])O\", True, 1)\n    )\n)\n\"\"\"\n\ndata = dm.freesolv()\ndata = data.iloc[:12]\n\ndata[\"mol\"] = data[\"smiles\"].apply(dm.to_mol)\n\ndm.to_image(data[\"mol\"].tolist(), n_cols=4, mol_size=(300, 150))\n</pre> # note that whitespace and newlines are ignored in the query query = \"\"\" (     HASPROP(\"tpsa\" &lt; 80) AND HASPROP(\"clogp\" &lt; 3) AND ! HASALERT(\"pains\") )      OR  (     HASPROP(\"n_heavy_atoms\" &gt;= 10)      AND      (         HASGROUP(\"Alcohols\")          OR          HASSUBSTRUCTURE(\"[CX3](=[OX1])O\", True, 1)     ) ) \"\"\"  data = dm.freesolv() data = data.iloc[:12]  data[\"mol\"] = data[\"smiles\"].apply(dm.to_mol)  dm.to_image(data[\"mol\"].tolist(), n_cols=4, mol_size=(300, 150)) Out[18]: In\u00a0[19]: Copied! <pre>query_filter = mc.query.QueryFilter(query)\nout = query_filter(data[\"smiles\"], n_jobs=-1, progress=True)\n\nout\n</pre> query_filter = mc.query.QueryFilter(query) out = query_filter(data[\"smiles\"], n_jobs=-1, progress=True)  out <pre>Loading Mols:   0%|          | 0/12 [00:00&lt;?, ?it/s]</pre> Out[19]: <pre>[True, True, True, True, True, True, True, True, True, True, True, True]</pre> In\u00a0[23]: Copied! <pre>data = dm.data.cdk2()\ndata = data.iloc[:8]\n\ndm.to_image(data[\"mol\"].tolist(), n_cols=4, mol_size=(300, 150))\n</pre> data = dm.data.cdk2() data = data.iloc[:8]  dm.to_image(data[\"mol\"].tolist(), n_cols=4, mol_size=(300, 150)) Out[23]: In\u00a0[24]: Copied! <pre>query = \"\"\"HASPROP(\"tpsa\" &lt; 120) AND HASSUBSTRUCTURE(\"[OH]\", True)\"\"\"\nchemical_filter = mc.query.QueryFilter(query, parser=\"lalr\")\n\nchemical_filter\n</pre> query = \"\"\"HASPROP(\"tpsa\" &lt; 120) AND HASSUBSTRUCTURE(\"[OH]\", True)\"\"\" chemical_filter = mc.query.QueryFilter(query, parser=\"lalr\")  chemical_filter Out[24]: <pre>((`fn(getprop, prop='tpsa')` &lt; 120.0) and `fn(hassubstructure, query='[OH]', is_smarts=True, operator=None, limit=None)`)</pre> In\u00a0[25]: Copied! <pre>out = chemical_filter(data[\"mol\"], n_jobs=1)\n\nout\n</pre> out = chemical_filter(data[\"mol\"], n_jobs=1)  out <pre>Loading Mols:   0%|          | 0/8 [00:00&lt;?, ?it/s]</pre> Out[25]: <pre>[False, False, False, False, False, True, True, True]</pre>"},{"location":"tutorials/Medchem_Query_Language.html#medchem-query-language","title":"Medchem Query Language\u00b6","text":"<p>The Medchem query language is a simple and intuitive language allowing to express a filtering procedure based on the Medchem API. It's particularly convenient in a context outside of Python. For example, you can build a frontend application to filter compounds while giving the user full flexibility how to input a filtering procedure.</p> <p>The query language is based on <code>lark</code>.</p>"},{"location":"tutorials/Medchem_Query_Language.html#example-1","title":"Example #1\u00b6","text":""},{"location":"tutorials/Medchem_Query_Language.html#example-2","title":"Example #2\u00b6","text":""},{"location":"tutorials/Medchem_Query_Language.html#syntax","title":"Syntax\u00b6","text":"<p>Any string provided as <code>query</code> argument needs to be quoted (similar to json) to avoid ambiguity in parsing.</p> <ul> <li><p>An example of valid query is <code>\"\"\"(HASPROP(\"tpsa\" &gt; 120 ) | HASSUBSTRUCTURE(\"c1ccccc1\")) AND NOT HASALERT(\"pains\") OR HASSUBSTRUCTURE(\"[OH]\", max, 2)\"\"\"</code>.</p> </li> <li><p>Examples of invalid queries are</p> <ul> <li><code>\"\"\"HASPROP(\"tpsa\" &gt; 120) OR HASSUBSTRUCTURE(\"[OH]\", True, &gt;, 3)\"\"\"</code> : unexpected wrong operator <code>&gt;</code></li> <li><code>\"\"\"HASPROP(tpsa &gt; 120)\"\"\"</code> : tpsa is not quoted</li> <li><code>\"\"\"HASPROP(\"tpsa\") &gt; 120\"\"\"</code> : this is not part of the language specification</li> <li><code>\"\"\"(HASPROP(\"tpsa\" &gt; 120) AND HASSUBSTRUCTURE(\"[OH]\", True, max, 3 )\"\"\"</code>: mismatching parenthesis <code>(</code></li> </ul> </li> <li><p><code>\"\"\"HASPROP(\"tpsa\" &gt; 120) OR HASSUBSTRUCTURE(\"CO\")\"\"\"</code>, <code>\"\"\"(HASPROP(\"tpsa\" &gt; 120)) OR (HASSUBSTRUCTURE(\"CO\"))\"\"\"</code> and <code>\"\"\"(HASPROP(\"tpsa\" &gt; 120) OR HASSUBSTRUCTURE(\"CO\"))\"\"\"</code> are equivalent</p> </li> </ul>"},{"location":"tutorials/Medchem_Query_Language.html#hasalert","title":"<code>HASALERT</code>\u00b6","text":"<p>Check whether a molecule has an <code>alert</code> from a catalog:</p> <pre># alert is one supported alert catalog by `medchem`. For example `pains`\nHASALERT(alert:str)\n</pre>"},{"location":"tutorials/Medchem_Query_Language.html#hasgroup","title":"<code>HASGROUP</code>\u00b6","text":"<p>Check whether a molecule has a specific functional group from a catalog</p> <pre># group is one supported functional group provided by `medchem`\nHASGROUP(group:str)\n</pre>"},{"location":"tutorials/Medchem_Query_Language.html#matchrule","title":"<code>MATCHRULE</code>\u00b6","text":"<p>Check whether a molecule match a predefined druglikeness <code>rule</code> from a catalog</p> <pre># rule is one supported rule provided by `medchem`. For example `rule_of_five`\nMATCHRULE(rule:str)\n</pre>"},{"location":"tutorials/Medchem_Query_Language.html#hassuperstructure","title":"<code>HASSUPERSTRUCTURE</code>\u00b6","text":"<p>Check whether a molecule has <code>query</code> as superstructure</p> <pre># query is a SMILES\nHASSUPERSTRUCTURE(query:str)\n</pre>"},{"location":"tutorials/Medchem_Query_Language.html#hassubstructure","title":"<code>HASSUBSTRUCTURE</code>\u00b6","text":"<p>Check whether a molecule has <code>query</code> as substructure.</p> <p>Note that providing the comma separator <code>,</code> is mandatory here as each variable is an argument.</p> <pre># query is a SMILES or a SMARTS, operator is defined below, is_smarts is a boolean\n\nHASSUBSTRUCTURE(query:str, is_smarts:Optional[bool], operator:Optional[str], limit:Optional[int])\n\n# which correspond to setting this default values\nHASSUBSTRUCTURE(query:str, is_smarts=False, operator=\"min\", limit=1)\n# same as\nHASSUBSTRUCTURE(query:str, is_smarts=None, operator=None, limit=None)\n</pre> <p>Not providing optional arguments is allowed, but they need to be provided in the exact same order shown above. Thus:</p> <ul> <li><code>HASSUBSTRUCTURE(\"CO\")</code></li> <li><code>HASSUBSTRUCTURE(\"CO\", False)</code></li> <li><code>HASSUBSTRUCTURE(\"CO\", False, min)</code></li> <li><code>HASSUBSTRUCTURE(\"CO\", False, min, 1)</code></li> </ul> <p>are all <code>valid</code> and <code>equivalent</code> (given their default values)</p> <p>Furthermore, since the correct argument map can be inferred when no ambiguity arises, the following <code>are valid but discouraged</code></p> <ul> <li><code>HASSUBSTRUCTURE(\"CO\", False, 1)</code></li> <li><code>HASSUBSTRUCTURE(\"CO\", min, 1)</code></li> </ul> <p>Whereas, this is invalid:</p> <ul> <li><code>HASSUBSTRUCTURE(\"CO\", min, False, 1)</code></li> </ul>"},{"location":"tutorials/Medchem_Query_Language.html#hasprop","title":"<code>HASPROP</code>\u00b6","text":"<p>Check whether a molecule has <code>prop</code> as property within a defined limit.</p> <p>Any comma <code>,</code> provided between arguments will be ignored</p> <pre># prop is a valid datamol.descriptors property, comparator is a required comparator operator and defined below\nHASPROP(prop:str comparator:str limit:float)\n</pre>"},{"location":"tutorials/Medchem_Query_Language.html#like","title":"<code>LIKE</code>\u00b6","text":"<p>Check whether a molecule is similar enough to another molecule.</p> <p>Any comma <code>,</code> provided between arguments will be ignored</p> <pre># query is a SMILES\nLIKE(query:str  comparator:str limit:float)\n</pre>"},{"location":"tutorials/Medchem_Query_Language.html#basic-operators","title":"Basic operators:\u00b6","text":"<ul> <li>comparator: one of <code>=</code> <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> <li>misc: the following misc values are accepted and parsed <code>true</code>, <code>false</code>, <code>True</code>, <code>False</code>, <code>TRUE</code>, <code>FALSE</code></li> <li>operator (can be quoted or unquoted):<ul> <li>MIN: <code>min</code>, <code>MIN</code></li> <li>MAX: <code>max</code>, <code>MAX</code></li> </ul> </li> <li>boolean operator:<ul> <li>AND operator : <code>AND</code> or <code>&amp;</code> or <code>&amp;&amp;</code> or <code>and</code></li> <li>OR operator : <code>OR</code> or <code>|</code> or <code>||</code> or <code>or</code></li> <li>NOT operator : <code>NOT</code> or <code>!</code> or <code>~</code> or <code>not</code></li> </ul> </li> </ul>"},{"location":"tutorials/Medchem_Rules.html","title":"Medchem Rules","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n    \nimport datamol as dm\nimport pandas as pd\n\nimport medchem as mc\n</pre> %load_ext autoreload %autoreload 2      import datamol as dm import pandas as pd  import medchem as mc <p>You can list all the available rules.</p> In\u00a0[2]: Copied! <pre>mc.rules.RuleFilters.list_available_rules()\n</pre> mc.rules.RuleFilters.list_available_rules() Out[2]: name rules description 0 rule_of_five MW &lt;= 500 &amp; logP &lt;= 5 &amp; HBD &lt;= 5 &amp; HBA &lt;= 10 leadlike;druglike;small molecule;library design 1 rule_of_five_beyond MW &lt;= 1000 &amp; logP in [-2, 10] &amp; HBD &lt;= 6 &amp; HBA... leadlike;druglike;small molecule;library design 2 rule_of_four MW &gt;= 400 &amp; logP &gt;= 4 &amp; RINGS &gt;=4 &amp; HBA &gt;= 4 PPI inhibitor;druglike 3 rule_of_three MW &lt;= 300 &amp; logP &lt;= 3 &amp; HBA &lt;= 3 &amp; HBD &lt;= 3 &amp; ... fragment;building block 4 rule_of_three_extended MW &lt;= 300 &amp; logP in [-3, 3] &amp; HBA &lt;= 6 &amp; HBD &lt;... fragment;building block 5 rule_of_two MW &lt;= 200 &amp; logP &lt;= 2 &amp; HBA &lt;= 4 &amp; HBD &lt;= 2 fragment;reagent;building block 6 rule_of_ghose MW in [160, 480] &amp; logP in [-0.4, 5.6] &amp; Natom... leadlike;druglike;small molecule;library design 7 rule_of_veber rotatable bond &lt;= 10 &amp; TPSA &lt; 140 druglike;leadlike;small molecule;oral 8 rule_of_reos MW in [200, 500] &amp; logP in [-5, 5] &amp; HBA in [0... druglike;small molecule;library design;HTS 9 rule_of_chemaxon_druglikeness MW &lt; 400 &amp; logP &lt; 5 &amp; HBA &lt;= 10 &amp; HBD &lt;= 5 &amp; r... leadlike;druglike;small molecule 10 rule_of_egan TPSA in [0, 132] &amp; logP in [-1, 6] druglike;small molecule;admet;absorption;perme... 11 rule_of_pfizer_3_75 not (TPSA &lt; 75 &amp; logP &gt; 3) druglike;toxicity;invivo;small molecule 12 rule_of_gsk_4_400 MW &lt;= 400 &amp; logP &lt;= 4 druglike;admet;small molecule 13 rule_of_oprea HBD in [0, 2] &amp; HBA in [2, 9] &amp; ROTBONDS in [2... druglike;small molecule 14 rule_of_xu HBD &lt;= 5 &amp; HBA &lt;= 10 &amp; ROTBONDS in [2, 35] &amp; R... druglike;small molecule;library design 15 rule_of_cns MW in [135, 582] &amp; logP in [-0.2, 6.1] &amp; TPSA ... druglike;CNS;BBB;small molecule 16 rule_of_respiratory MW in [240, 520]  &amp; logP in [-2, 4.7] &amp; HBONDS... druglike;respiratory;small molecule;nasal;inha... 17 rule_of_zinc MW in [60, 600] &amp; logP &lt; in [-4, 6] &amp; HBD &lt;= 6... druglike;small molecule;library design;zinc 18 rule_of_leadlike_soft MW in [150, 400] &amp; logP &lt; in [-3, 4] &amp; HBD &lt;= ... leadlike;small molecule;library design;admet 19 rule_of_druglike_soft MW in [100, 600] &amp; logP &lt; in [-3, 6] &amp; HBD &lt;= ... druglike;small molecule;library design 20 rule_of_generative_design MW in [200, 600] &amp; logP &lt; in [-3, 6] &amp; HBD &lt;= ... druglike;small molecule;de novo design;generat... 21 rule_of_generative_design_strict MW in [200, 600] &amp; logP &lt; in [-3, 6] &amp; HBD &lt;= ... druglike;small molecule;de novo design;generat... <p>You can also filter the rules using the tags in their descriptions:</p> In\u00a0[3]: Copied! <pre>mc.rules.RuleFilters.list_available_rules(\"building block\")\n</pre> mc.rules.RuleFilters.list_available_rules(\"building block\") Out[3]: name rules description 3 rule_of_three MW &lt;= 300 &amp; logP &lt;= 3 &amp; HBA &lt;= 3 &amp; HBD &lt;= 3 &amp; ... fragment;building block 4 rule_of_three_extended MW &lt;= 300 &amp; logP in [-3, 3] &amp; HBA &lt;= 6 &amp; HBD &lt;... fragment;building block 5 rule_of_two MW &lt;= 200 &amp; logP &lt;= 2 &amp; HBA &lt;= 4 &amp; HBD &lt;= 2 fragment;reagent;building block <p>Given a list of rules, you can create a <code>RuleFilters</code> object in order to filter a list of molecules.</p> In\u00a0[4]: Copied! <pre># Create the filter object\nrfilter = mc.rules.RuleFilters(\n    # You can specifiy a rule as a string or as a callable\n    rule_list=[\"rule_of_five\", \"rule_of_oprea\", \"rule_of_cns\", \"rule_of_leadlike_soft\"],\n    # You can specify a custom list of names\n    rule_list_names=[\"rule_of_five\", \"rule_of_oprea\", \"rule_of_cns\", \"rule_of_leadlike_soft\"],\n)\n</pre> # Create the filter object rfilter = mc.rules.RuleFilters(     # You can specifiy a rule as a string or as a callable     rule_list=[\"rule_of_five\", \"rule_of_oprea\", \"rule_of_cns\", \"rule_of_leadlike_soft\"],     # You can specify a custom list of names     rule_list_names=[\"rule_of_five\", \"rule_of_oprea\", \"rule_of_cns\", \"rule_of_leadlike_soft\"], ) In\u00a0[7]: Copied! <pre># Load a dataset\ndata = dm.data.solubility()\ndata = data.sample(50, random_state=20)\n\ndm.to_image(data.iloc[:8][\"mol\"].tolist(), mol_size=(300, 250))\n</pre> # Load a dataset data = dm.data.solubility() data = data.sample(50, random_state=20)  dm.to_image(data.iloc[:8][\"mol\"].tolist(), mol_size=(300, 250)) Out[7]: <p>Apply our rule filters on the list of molecules.</p> In\u00a0[8]: Copied! <pre>results = rfilter(\n    mols=data[\"mol\"].tolist(),\n    n_jobs=-1,\n    progress=True,\n    progress_leave=True,\n    scheduler=\"auto\",\n    keep_props=False,\n    fail_if_invalid=True,\n)\n\nresults.head()\n</pre> results = rfilter(     mols=data[\"mol\"].tolist(),     n_jobs=-1,     progress=True,     progress_leave=True,     scheduler=\"auto\",     keep_props=False,     fail_if_invalid=True, )  results.head() <pre>Filter by rules:   0%|          | 0/50 [00:00&lt;?, ?it/s]</pre> Out[8]: mol pass_all pass_any rule_of_five rule_of_oprea rule_of_cns rule_of_leadlike_soft 0 &lt;rdkit.Chem.rdchem.Mol object at 0x7f453a36fa70&gt; False True True False False False 1 &lt;rdkit.Chem.rdchem.Mol object at 0x7f453a382810&gt; False True True False True True 2 &lt;rdkit.Chem.rdchem.Mol object at 0x7f453a375850&gt; False True True False False False 3 &lt;rdkit.Chem.rdchem.Mol object at 0x7f453a373b50&gt; True True True True True True 4 &lt;rdkit.Chem.rdchem.Mol object at 0x7f453a37c350&gt; False True True False True True <p>You will noticde that the columns <code>pass_all</code> and <code>pass_any</code> will indicate whether a molecule has passed either all or at least one of the rules.</p> <p>Display the results.</p> In\u00a0[59]: Copied! <pre>rows = results.iloc[:8]\n\nmols = rows[\"mol\"].iloc[:8].tolist()\nlegends = rows[[\"pass_all\", \"pass_any\"]].apply(lambda x: f\"pass_all={x[0]} - pass_any={x[1]}\", axis=1).tolist()\n\ndm.to_image(mols, legends=legends, mol_size=(300, 250))\n</pre> rows = results.iloc[:8]  mols = rows[\"mol\"].iloc[:8].tolist() legends = rows[[\"pass_all\", \"pass_any\"]].apply(lambda x: f\"pass_all={x[0]} - pass_any={x[1]}\", axis=1).tolist()  dm.to_image(mols, legends=legends, mol_size=(300, 250)) Out[59]: <p>List the available rule by their names.</p> In\u00a0[60]: Copied! <pre>rule_names = mc.rules.RuleFilters.list_available_rules()[\"name\"].tolist()\nrule_names\n</pre> rule_names = mc.rules.RuleFilters.list_available_rules()[\"name\"].tolist() rule_names Out[60]: <pre>['rule_of_five',\n 'rule_of_five_beyond',\n 'rule_of_four',\n 'rule_of_three',\n 'rule_of_three_extended',\n 'rule_of_two',\n 'rule_of_ghose',\n 'rule_of_veber',\n 'rule_of_reos',\n 'rule_of_chemaxon_druglikeness',\n 'rule_of_egan',\n 'rule_of_pfizer_3_75',\n 'rule_of_gsk_4_400',\n 'rule_of_oprea',\n 'rule_of_xu',\n 'rule_of_cns',\n 'rule_of_respiratory',\n 'rule_of_zinc',\n 'rule_of_leadlike_soft',\n 'rule_of_druglike_soft',\n 'rule_of_generative_design',\n 'rule_of_generative_design_strict']</pre> <p>The rules are available at <code>mc.rules.basic_rules.*</code>. You can retrieve a rule with:</p> <ul> <li>the direct import <code>mc.rules.basic_rules.rule_of_five</code>.</li> <li>by its name: <code>getattr(mc.rules.basic_rules, \"rule_of_five\")</code></li> </ul> <p>Let's do it!</p> In\u00a0[61]: Copied! <pre># Get some rules\nrule_1 = mc.rules.basic_rules.rule_of_five\nrule_2 = getattr(mc.rules.basic_rules, \"rule_of_chemaxon_druglikeness\")\n\n# Get a molecule\nmol = dm.to_mol(\" CN(C)CCOC(C1=CC=CC=C1)C1=CC=CC=C1\")\n\nmol\n</pre> # Get some rules rule_1 = mc.rules.basic_rules.rule_of_five rule_2 = getattr(mc.rules.basic_rules, \"rule_of_chemaxon_druglikeness\")  # Get a molecule mol = dm.to_mol(\" CN(C)CCOC(C1=CC=CC=C1)C1=CC=CC=C1\")  mol Out[61]: In\u00a0[62]: Copied! <pre># Apply rule #1\nrule_1(mol)\n</pre> # Apply rule #1 rule_1(mol) Out[62]: <pre>True</pre> In\u00a0[63]: Copied! <pre># Apply rule #2\nrule_2(mol)\n</pre> # Apply rule #2 rule_2(mol) Out[63]: <pre>False</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/Medchem_Rules.html#medchem-rules","title":"Medchem Rules\u00b6","text":"<p>Medchem rules can be useful to quickly flag or triage compounds that do not meet certain basic molecular properties criteria (such as MW, TSPA, cLogP, etc).</p> <p>You can find more informations about the rules and their origins within their docstring or in the API documentation.</p> <p>The below tutorial will introduce you how to apply those rules to a list of molecules.</p>"},{"location":"tutorials/Medchem_Rules.html#filtering-with-rules","title":"Filtering with rules\u00b6","text":""},{"location":"tutorials/Medchem_Rules.html#low-level-api","title":"Low level API\u00b6","text":"<p>You can use the low level API to filter molecules.</p>"},{"location":"tutorials/Molecular_Complexity.html","title":"Molecular Complexity","text":"In\u00a0[1]: Copied! <pre>import datamol as dm\nimport pandas as pd\n\nimport medchem as mc\n</pre> import datamol as dm import pandas as pd  import medchem as mc In\u00a0[15]: Copied! <pre>mc.complexity.ComplexityFilter.list_default_available_filters()\n</pre> mc.complexity.ComplexityFilter.list_default_available_filters() Out[15]: <pre>['bertz', 'sas', 'qed', 'clogp', 'whitlock', 'barone', 'smcm', 'twc']</pre> In\u00a0[16]: Copied! <pre>mc.complexity.ComplexityFilter.list_default_percentile()\n</pre> mc.complexity.ComplexityFilter.list_default_percentile() Out[16]: <pre>['99', '999', 'max']</pre> In\u00a0[14]: Copied! <pre>mc.complexity.ComplexityFilter.load_threshold_stats_file().head()\n</pre> mc.complexity.ComplexityFilter.load_threshold_stats_file().head() Out[14]: bertz whitlock barone smcm mw_bins percentile 0 257.0 14.0 234.0 21.7 150.0 99 1 394.0 17.0 309.0 28.8 200.0 99 2 525.0 20.0 384.0 35.0 250.0 99 3 679.0 23.0 462.0 40.2 300.0 99 4 864.0 26.0 540.0 44.0 350.0 99 <p>Load some molecules.</p> In\u00a0[27]: Copied! <pre>data = dm.data.cdk2()\ndata = data.iloc[:8]\n\n# Let's remove the conformers since they are not important here.\ndata[\"mol\"].apply(lambda x: x.RemoveAllConformers())\n\ndm.to_image(data[\"mol\"].tolist(), mol_size=(300, 200))\n</pre> data = dm.data.cdk2() data = data.iloc[:8]  # Let's remove the conformers since they are not important here. data[\"mol\"].apply(lambda x: x.RemoveAllConformers())  dm.to_image(data[\"mol\"].tolist(), mol_size=(300, 200)) Out[27]: <p>Load the complexity filter.</p> In\u00a0[31]: Copied! <pre>cfilter = mc.complexity.ComplexityFilter(threshold_stats_file=\"zinc_12\", complexity_metric=\"whitlock\")\n\ncfilter.complexity_metric\n</pre> cfilter = mc.complexity.ComplexityFilter(threshold_stats_file=\"zinc_12\", complexity_metric=\"whitlock\")  cfilter.complexity_metric Out[31]: <pre>'whitlock'</pre> <p>Apply the filter on our list of molecules. <code>True</code> means it passes the filter and <code>False</code> mean the molecule is too complex.</p> In\u00a0[32]: Copied! <pre>data[\"pass_cfilter\"] = data[\"mol\"].apply(cfilter)\n\ndata[\"pass_cfilter\"]\n</pre> data[\"pass_cfilter\"] = data[\"mol\"].apply(cfilter)  data[\"pass_cfilter\"] Out[32]: <pre>0     True\n1    False\n2    False\n3     True\n4    False\n5     True\n6     True\n7     True\nName: pass_cfilter, dtype: bool</pre> In\u00a0[35]: Copied! <pre>legends = data[\"pass_cfilter\"].apply(lambda x: f\"Pass={x}\").tolist()\n\ndm.to_image(data[\"mol\"].tolist(), legends=legends, mol_size=(300, 200))\n</pre> legends = data[\"pass_cfilter\"].apply(lambda x: f\"Pass={x}\").tolist()  dm.to_image(data[\"mol\"].tolist(), legends=legends, mol_size=(300, 200)) Out[35]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/Molecular_Complexity.html#molecular-complexity","title":"Molecular Complexity\u00b6","text":"<p>The <code>ComplexityFilter</code> allows to filter a molecule according to its \"structural complexity\". It's often a good filter to discard compounds that might be challenging to synthetize.</p>"},{"location":"tutorials/Molecular_Complexity.html#available-filters","title":"Available filters\u00b6","text":""},{"location":"tutorials/Molecular_Complexity.html#usage","title":"Usage\u00b6","text":""},{"location":"tutorials/Structural_Filters.html","title":"Structural Filters","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n\nimport datamol as dm\nimport pandas as pd\n\nimport medchem as mc\n</pre> %load_ext autoreload %autoreload 2  import datamol as dm import pandas as pd  import medchem as mc <p>You can list all the available default filters.</p> In\u00a0[2]: Copied! <pre>mc.structural.CommonAlertsFilters.list_default_available_alerts()\n</pre> mc.structural.CommonAlertsFilters.list_default_available_alerts() Out[2]: rule_set_name smarts catalog_description rule_set source 0 Glaxo 55 Glaxo Wellcome Hard filters 1 ChEMBL 1 Dundee 105 University of Dundee NTD Screening Library Fil... 2 ChEMBL 2 BMS 180 Bristol-Myers Squibb HTS Deck filters 3 ChEMBL 3 PAINS 481 PAINS filters 4 ChEMBL 4 SureChEMBL 166 SureChEMBL Non-MedChem Friendly SMARTS 5 ChEMBL 5 MLSMR 116 NIH MLSMR Excluded Functionality filters (MLSMR) 6 ChEMBL 6 Inpharmatica 91 Unwanted fragments derived by Inpharmatica Ltd. 7 ChEMBL 7 LINT 57 Pfizer lint filters (lint) 8 ChEMBL 8 Alarm-NMR 75 Reactive False Positives in Biochemical Screen... 9 Litterature 9 AlphaScreen-Hitters 6 Structural filters for compounds that may be a... 10 Litterature 10 GST-Hitters 34 Structural filters for compounds may prevent G... 11 Litterature 11 HIS-Hitters 19 Structural filters for compounds prevents the ... 12 Litterature 12 LuciferaseInhibitor 3 Structural filters for compounds that may inhi... 13 Litterature 13 DNABinder 78 Structural filters for compounds that may bind... 14 Litterature 14 Chelator 55 Structural filters for compounds that may inhi... 15 Litterature 15 Frequent-Hitter 15 Structural filters for compounds that are freq... 16 Litterature 16 Electrophilic 119 Structural filters for compounds that could ta... 17 Litterature 17 Genotoxic-Carcinogenicity 117 Structural filters for compounds that may caus... 18 Litterature 18 LD50-Oral 20 Structural filters for compounds that may caus... 19 Litterature 19 Non-Genotoxic-Carcinogenicity 22 Structural filters for compounds that may caus... 20 Litterature 20 Reactive-Unstable-Toxic 335 General very reactive/unstable or Toxic compounds 21 Litterature 21 Skin 155 Skin Sensitization filters (irritables) 22 Litterature 22 Toxicophore 154 General Toxicophores 23 Litterature <p>Create a <code>CommonAlertsFilters</code> object in order to filter a list of molecules.</p> In\u00a0[3]: Copied! <pre>alerts = mc.structural.CommonAlertsFilters()\n</pre> alerts = mc.structural.CommonAlertsFilters() <p>By default only the \"Glaxo\", \"Dundee\" and \"BMS\" set are used but you can specify your own set:</p> In\u00a0[4]: Copied! <pre>alerts2 = mc.structural.CommonAlertsFilters(alerts_set=[\"LINT\", \"Toxicophore\"])\n</pre> alerts2 = mc.structural.CommonAlertsFilters(alerts_set=[\"LINT\", \"Toxicophore\"]) <p>Let's load a few molecules.</p> In\u00a0[5]: Copied! <pre># Load a dataset\ndata = dm.data.solubility()\ndata = data.sample(50, random_state=20)\n\ndm.to_image(data.iloc[:8][\"mol\"].tolist(), mol_size=(300, 250))\n</pre> # Load a dataset data = dm.data.solubility() data = data.sample(50, random_state=20)  dm.to_image(data.iloc[:8][\"mol\"].tolist(), mol_size=(300, 250)) Out[5]: <p>Apply the filters on the list of molecules.</p> In\u00a0[6]: Copied! <pre>results = alerts(\n    mols=data[\"mol\"].tolist(),\n    n_jobs=-1,\n    progress=True,\n    progress_leave=True,\n    scheduler=\"auto\",\n)\n\nresults.head()\n</pre> results = alerts(     mols=data[\"mol\"].tolist(),     n_jobs=-1,     progress=True,     progress_leave=True,     scheduler=\"auto\", )  results.head() <pre>Filter by alerts:   0%|          | 0/50 [00:00&lt;?, ?it/s]</pre> Out[6]: mol pass_filter status reasons 0 &lt;rdkit.Chem.rdchem.Mol object at 0x7f4e549e5690&gt; True ok None 1 &lt;rdkit.Chem.rdchem.Mol object at 0x7f4e53fc5d20&gt; False exclude Polycyclic aromatic hydrocarbon 2 &lt;rdkit.Chem.rdchem.Mol object at 0x7f4e549ccba0&gt; False exclude aniline 3 &lt;rdkit.Chem.rdchem.Mol object at 0x7f4e549ce8f0&gt; True ok None 4 &lt;rdkit.Chem.rdchem.Mol object at 0x7f4e549b9ee0&gt; True ok None <p>Display the results.</p> In\u00a0[7]: Copied! <pre>rows = results.iloc[:8]\n\nmols = rows[\"mol\"].iloc[:8].tolist()\nlegends = (\n    rows[[\"pass_filter\", \"reasons\"]].apply(lambda x: f\"pass_filter={x[0]}\\nreasons={x[1]}\", axis=1).tolist()\n)\n\ndm.to_image(mols, legends=legends, mol_size=(300, 250))\n</pre> rows = results.iloc[:8]  mols = rows[\"mol\"].iloc[:8].tolist() legends = (     rows[[\"pass_filter\", \"reasons\"]].apply(lambda x: f\"pass_filter={x[0]}\\nreasons={x[1]}\", axis=1).tolist() )  dm.to_image(mols, legends=legends, mol_size=(300, 250)) Out[7]: <p>Load the NIBR filters.</p> In\u00a0[11]: Copied! <pre>nibr_filters = mc.structural.NIBRFilters()\n</pre> nibr_filters = mc.structural.NIBRFilters() <p>Let's load a few molecules.</p> In\u00a0[9]: Copied! <pre># Load a dataset\ndata = dm.data.solubility()\ndata = data.sample(50, random_state=20)\n\ndm.to_image(data.iloc[:8][\"mol\"].tolist(), mol_size=(300, 250))\n</pre> # Load a dataset data = dm.data.solubility() data = data.sample(50, random_state=20)  dm.to_image(data.iloc[:8][\"mol\"].tolist(), mol_size=(300, 250)) Out[9]: <p>Apply the filters on the list of molecules.</p> In\u00a0[16]: Copied! <pre>results = nibr_filters(\n    mols=data[\"mol\"].tolist(),\n    n_jobs=-1,\n    progress=True,\n    progress_leave=True,\n    scheduler=\"threads\",\n    keep_details=True,\n)\n\nresults.head()\n</pre> results = nibr_filters(     mols=data[\"mol\"].tolist(),     n_jobs=-1,     progress=True,     progress_leave=True,     scheduler=\"threads\",     keep_details=True, )  results.head() <pre>NIBR filtering:   0%|          | 0/50 [00:00&lt;?, ?it/s]</pre> Out[16]: mol reasons severity status n_covalent_motif special_mol pass_filter details 0 &lt;rdkit.Chem.rdchem.Mol object at 0x7f4e517642e0&gt; ketals _or_acetals_min(1); steroid_non_arom_mi... 10 exclude 0 2 False {'name': {0: 'ketals _or_acetals_min(1)', 1: '... 1 &lt;rdkit.Chem.rdchem.Mol object at 0x7f4e515b71b0&gt; polycyclic_systems_14_atoms_min(1) 0 annotations 0 1 True {'name': {0: 'polycyclic_systems_14_atoms_min(... 2 &lt;rdkit.Chem.rdchem.Mol object at 0x7f4e5176e030&gt; None 0 ok 0 0 True NaN 3 &lt;rdkit.Chem.rdchem.Mol object at 0x7f4e5176c3c0&gt; None 0 ok 0 0 True NaN 4 &lt;rdkit.Chem.rdchem.Mol object at 0x7f4e515bcb30&gt; None 0 ok 0 0 True NaN In\u00a0[18]: Copied! <pre>results.columns.tolist()\n</pre> results.columns.tolist() Out[18]: <pre>['mol',\n 'reasons',\n 'severity',\n 'status',\n 'n_covalent_motif',\n 'special_mol',\n 'pass_filter',\n 'details']</pre> <p>Display the results.</p> In\u00a0[14]: Copied! <pre>rows = results.iloc[:8]\n\nmols = rows[\"mol\"].iloc[:8].tolist()\nlegends = (\n    rows[[\"pass_filter\", \"status\"]].apply(lambda x: f\"pass_filter={x[0]} - status={x[1]}\", axis=1).tolist()\n)\n\ndm.to_image(mols, legends=legends, mol_size=(300, 250))\n</pre> rows = results.iloc[:8]  mols = rows[\"mol\"].iloc[:8].tolist() legends = (     rows[[\"pass_filter\", \"status\"]].apply(lambda x: f\"pass_filter={x[0]} - status={x[1]}\", axis=1).tolist() )  dm.to_image(mols, legends=legends, mol_size=(300, 250)) Out[14]: In\u00a0[23]: Copied! <pre># Load a dataset\ndata = dm.data.solubility()\ndata = data.sample(50, random_state=20)\n\ndm.to_image(data.iloc[:8][\"mol\"].tolist(), mol_size=(300, 250))\n</pre> # Load a dataset data = dm.data.solubility() data = data.sample(50, random_state=20)  dm.to_image(data.iloc[:8][\"mol\"].tolist(), mol_size=(300, 250)) Out[23]: In\u00a0[24]: Copied! <pre>from medchem.structural.lilly_demerits import LillyDemeritsFilters\n\ndfilter = LillyDemeritsFilters()\n</pre> from medchem.structural.lilly_demerits import LillyDemeritsFilters  dfilter = LillyDemeritsFilters() In\u00a0[25]: Copied! <pre>results = dfilter(\n    mols=data[\"mol\"].tolist(),\n    n_jobs=-1,\n    progress=True,\n    progress_leave=True,\n    scheduler=\"threads\",\n)\n\nresults.head()\n</pre> results = dfilter(     mols=data[\"mol\"].tolist(),     n_jobs=-1,     progress=True,     progress_leave=True,     scheduler=\"threads\", )  results.head() Out[25]: smiles reasons step demerit_score status pass_filter mol 0 CC1(C)OC2CC3C4CCC5=CC(=O)C=CC5(C)C4(F)C(O)CC3(... michael_rejected 2 NaN exclude False &lt;rdkit.Chem.rdchem.Mol object at 0x7f58d6f23530&gt; 1 C1=CC2=C(C=C1)C1=NC=CN=C1C=C2 phenanthrene_het:D60 2 60.0 flag True &lt;rdkit.Chem.rdchem.Mol object at 0x7f58d66f9c40&gt; 2 NC1=CC=CC=C1Cl aniline_h_newd:D50,aniline_h_ewd:D10 2 60.0 flag True &lt;rdkit.Chem.rdchem.Mol object at 0x7f5a7da61ee0&gt; 3 O=C(O)CCC(=O)C1=CC=C(C2=CC=CC=C2)C=C1 NaN 2 0.0 ok True &lt;rdkit.Chem.rdchem.Mol object at 0x7f58d6da4c10&gt; 4 CC(C)N1C(=O)C2=CC=CC=C2NS1(=O)=O NaN 2 0.0 ok True &lt;rdkit.Chem.rdchem.Mol object at 0x7f58d5a5b610&gt; In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/Structural_Filters.html#structural-filters","title":"Structural Filters\u00b6","text":"<p>Structural filters can be used to triage or flag compounds that contains a specific molecular features that can often be unwanted or undesired. Medchem proposes 3 types of structural filters:</p> <ul> <li>Common Alerts: a list of filters curated and aggregated from ChEMBL and the public litterature. The original curation was performed by Patrick Walters and proposed at https://github.com/PatWalters/rd_filters.</li> <li>NIBR Filters: Novartis screening deck originally proposed in Evolution of Novartis\u2019 Small Molecule Screening Deck Design.</li> <li>Eli Lilly Demerits Filters: A set of 275 rules used to identify compounds that may interfere with biological assays. Originally proposed in Rules for Identifying Potentially Reactive or Promiscuous Compounds.</li> </ul>"},{"location":"tutorials/Structural_Filters.html#common-alerts","title":"Common Alerts\u00b6","text":""},{"location":"tutorials/Structural_Filters.html#nibr-filters","title":"NIBR Filters\u00b6","text":""},{"location":"tutorials/Structural_Filters.html#eli-lilly-demerits-filters","title":"Eli Lilly Demerits Filters\u00b6","text":""}]}